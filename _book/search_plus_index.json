{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 个人整理的学习资料和笔记 "},"1 Koa/":{"url":"1 Koa/","title":"1 Koa","keywords":"","body":"Koa 学习路径 koa 基础使用 koa级联以及中间件顺序 koa-router koa-bodyparse koa-static 以及passport第三方登录 jwt鉴权 passport表单验证 "},"1 Koa/1.1 DOC-Koa 以及中间件学习笔记.html":{"url":"1 Koa/1.1 DOC-Koa 以及中间件学习笔记.html","title":"1.1 DOC-Koa 以及中间件学习笔记","keywords":"","body":"Koa 以及中间件学习笔记 级联 next() 暂停当前函数的执行，进行下面函数的执行，然后会到上游next函数执行处，继续向下执行。 const Koa =require('koa') const app = new Koa() app.use(async (ctx, next) =>{ console.log(1) await next() const rt = ctx.response.get('X-Response-Time') console.log(`${ctx.method} ${ctx.url} - ${rt}`); console.log(2) }) app.use(async (ctx, next) =>{ console.log(3) const start =Date.now() await next() const ms= Date.now() - start ctx.set('X-Response-Time',`${ms}ms`) console.log(4); }) app.use(async ctx =>{ ctx.body='Hello world' console.log(5) }) app.listen(3000) // 1 3 5 4 2 属性 app的属性和方法 app.env 环境变量 默认使NODE_ENV development app.proxy //设置代理 app.subdomainOffset 可以监听多个端口 app.callback() 将方法用于 http.createServer https.createServer 或者connect 和express程序 app.use(function) 将给定的中间件方法添加到此应用程序 app.keys 设置Cookie 密匙 app.context 从外部直接向ctx 内部添加属性 app.context.db = db(); app.use(async ctx => { console.log(ctx.db); }); 错误处理 通过监听 error 事件进行事件处理 app.on('error', err , ctx=> { //ctx 可以继续向下传递 log.error('server error', err) //错误日志 }); ctx 属性 基本属性 ctx.req ctx.res node 的请求与相应对象 ctx.responce ctx.request koa 的对象 ctx.state 推荐的进行变量绑定的地方 ctx.app app对象 ctx.app.emit 触发on的绑定事件 ctx.cookies.set 设置cookie ctx.cookies.get 获取cookis ctx.throw([status], [msg], [properties]) 通常使用户的错误 而不是服务器的错误 http-errors ctx.assert(value, [status], [msg], [properties]) 用于断言 当第一个值为false的时候 第二值为错误码 第三个值使message http-assert Request 别名 以下访问器和 Request 别名等效： ctx.header 请求的标识头 可设置 ctx.headers ==上面 ctx.method 请求方法 可设置 ctx.url 请求的url 可设置 ctx.originalUrl 获取请求原始URL ctx.origin 获取URL的来源，包括 protocol 和 host。 ctx.href ctx.path ctx.path= ctx.query ctx.query= ctx.querystring ctx.querystring= ctx.host ctx.hostname http://localhost:3000 -------origin 常用 http://localhost:3000/apple?abc=11111 -------href /apple?abc=11111 -------originalUrl /apple -------path 常用 /apple?abc=11111 -------url { abc: '11111' } -------query 常用 abc=11111 -------querystring localhost:3000 -------host localhost -------hostname ctx.fresh 检查缓存是否新鲜 也就是内容没有改变。 在设置一个或多个这些响应头后应该引用它。 ctx.stale 以上面相反 ctx.socket request.socket 返回请求套接字。 ctx.protocol 返回请求协议，“https” 或 “http”。当 app.proxy 是 true 时支持 X-Forwarded-Proto。 ctx.secure 通过 ctx.protocol == \"https\" 来检查请求是否通过 TLS 发出。 ctx.ip 返回请求的IP ctx.ips 返回转发过后的多个IP ctx.subdomains 返回子域名 根据 subdomainsoffset偏移量试着 ctx.is() 检查传入请求是否包含 Content-Type 头字段， 并且包含任意的 mime type。 如果没有请求主体，返回 null。 如果没有内容类型，或者匹配失败，则返回 false。 反之则返回匹配的 content-type。 ctx.accepts() request.accepts(types) 通过类型检查 可以适用switch设置 ctx.acceptsEncodings() request.acceptsEncodings(encodings) encodings检查 ctx.acceptsCharsets() request.acceptsCharsets(charsets) 编码类型检查 ctx.acceptsLanguages() request.acceptsLanguages(langs) 语言类型检查 ctx.get() request.get(field) 返回请求标头。 Response 别名 以下访问器和 Response 别名等效： ctx.body ctx.body= string 写入 Buffer 写入 Stream 管道 Object || Array JSON-字符串化 null 无内容响应 ctx.status 状态码 ctx.status= ctx.message 信息 ctx.message= ctx.length= 长度 ctx.length ctx.type= 获取响应 Content-Type 不含参数 \"charset\"。 ctx.type ctx.headerSent 检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知。 ctx.redirect() response.redirect(url, [alt]) ctx.attachment()将 Content-Disposition 设置为 “附件” 以指示客户端提示下载。(可选)指定下载的 filename 和部分 参数。 ctx.set() 设置响应标头 field 到 value: 用一个对象设置多个响应标头fields: ctx.append() 用值 val 附加额外的标头 field。 ctx.remove() 移除表头 ctx.lastModified= 将 Last-Modified 标头返回为 Date, 如果存在。 检查最后的更改事件 ctx.etag= 设置etag 头部 response.is(types...) 。这对于创建操纵响应的中间件特别有用。 html-minifier，可以削减除流之外的所有HTML响应。 response.vary(field) 查看在 field 上变化。 response.flushHeaders() 刷新任何设置的标头，并开始主体。 缓存 使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control Cache-Control 响应头表示了资源是否可以被缓存，以及缓存的有效期。 no-cache 为本次响应不可直接用于后续请求（在没有向服务器进行校验的情况下） no-store 为禁止缓存（不得存储到非易失性介质，如果有的话尽量移除，用于敏感信息） private为仅 UA 可缓存 public为大家都可以缓存。 可以添加过期时间 max-age Etag 响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。 Etag 响应头字段表示资源的版本 浏览器在发送请求时会带 If-None-Match 头字段， Last-Modified 响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。 if-modified-since 在请求头中 时间戳 如果没有过过期时间则可以直接适用缓存 返回304 而不返回任何资源 否则返回一个Last-Modified', new Date().toString() 设置新时间 "},"1 Koa/1.2 KoaRouter.html":{"url":"1 Koa/1.2 KoaRouter.html","title":"1.2 KoaRouter","keywords":"","body":"koa-router 路由使用 /* * @Author: yu-lei * @Date: 2019-08-22 20:02:15 * @Last Modified by: yu-lei * @Last Modified time: 2019-08-22 23:06:14 */ /** * 包区域 */ const koa =require('koa') const koaRouter = require('koa-router') const koaBodyparser = require('koa-bodyparser') /** * 定义区域 */ const app =new koa() const router = new koaRouter() /** * 文件区域 */ //路由 const userRoutes = require('./routers/users')() const homeRoutes = require('./routers/homes')() /** * 中间件 */ app.use(koaBodyparser()) app.use(router.routes()) app.use(homeRoutes.routes()) app.use(userRoutes.routes()) app.use(router.allowedMethods()) //开启所有的请求方法 /** * 服务器 */ app.listen(3000, () =>{ console.log(\"服务器已经开启！\") }) 路由匹配方式 router.all('/*' , async (ctx,next) =>{ console.log(ctx.url) // 决绝特殊访问服务 // 搜索引擎优化 //roubat // 过滤服务 await next() }) router.get()// get|put|post|patch|delete|del|all router.regiest('path','GET',(ctx.next)=>{}) // 注册方法 路由的三种传递参数方式 通过动态router 传递 通过ctx.params.id 获取 router.get('/home/:id',async (ctx,next) =>{ ctx.body=\"home route\" console.log(ctx.params.id) // }) 通过query 字符串传递 通过ctx.query.参数名称获取 router.get('/home',async (ctx,next) =>{ ctx.body=\"home route\" console.log(ctx.query.id) // }) 通过post 传递 通过 koa-bodyparser 内的 ctx.request.body 获取 router.post('/home',async (ctx) =>{ console.log(ctx.request.body) ctx.body=ctx.request.body // console.log(ctx.request.body) }) redirect router.redirect('从那个路由'，’跳转到那个路由‘，状态码) // redirect 可能不需要匹配prefex 和父组件也会 匹配到路由跳转 use 嵌套路由 const userRouter = new koaRouter({ prefix:'/user' }) userRouter.get('/admin',async ctx=>{ //todo }) //中间件使用方法 router.use('/home',userRouter.routes(),userRouter.allowedMethods({配置})) //请求地址为 // /home/user/admin 显示嵌套的父级路由 然后是子集路由的prefix 然后是接口 router.param(param, middleware) 所有带有id 参数的路由全部需要先经过这个路由 const router = new koaRouter({ prefix:'/home' }) //子路由 router // 所有带有id 参数的路由全部需要先经过这个路由 .param('id',async (id, ctx, next) =>{ console.log(ctx.path,'param'); await next() }) .get('/user/:id' , async ctx =>{ console.log(1,ctx.params.id) }) .get('/haha/:id' , async ctx =>{ console.log(2,ctx.params.id) }) .redirect('/abc/:id','/haha/1',303) return router "},"1 Koa/1.3 鉴权的几种方法.html":{"url":"1 Koa/1.3 鉴权的几种方法.html","title":"1.3 鉴权的几种方法","keywords":"","body":"权限鉴定的几种协议 1 cookie session 中的用户名密码 cookie 存储机制，http 本身是无状态的 cookie 是存储http状态 cookie-session 可以自定义加密 使用redis 或mongoose做session持久化存储 2 oauth2 一种新的协议 解决的问题：实现第三方登录给三方服务一些简单的用户信息具体解决第三方的授权问题和密码问题 方法：客户端和服务提供商之间提供了一个授权层，客户端不能直接登录服务提供商，只能登录授权层，与用户的密码不同，可以在登录的时候指定授权层的令牌的范围和有效期，服务提供商根据令牌的权限范围和有效期想客户端开放资料 客户端的授权模式由四种授权码模式，简化，密码，客户端模式 授权码模式就是用户同意后服务器给客户端一个授权码，然后客户端与服务端重新核实。 客户端模式适合还需要用户来注册的可以拿到用户较多信息 3 jwt json web token 实现 router.get('/login', function(req, res, next) { const { username } = req.query const user = { username, expireAt: Date.now().valueOf() + 20 * 60 * 1000 //增加一个过期时间 来控制安全 } const token = JWT.sign(user, 'asdasfgfdghd;lk;') res.send(token) }) 发射到客户端后会产生一个由三部分产生的字符串 1 部分是一个 base64 编码的字符串 解码后得到 {alg:加密格式（hs256）,typ:类型（jwt）} 2 签名数据 发送的东西，和时间戳 3 不能解码的密钥 使用算法加密的 使用的时候 # 把发送过来的token 放在请求头中 router.get('/hello', (req, res, next) => { const auth = req.get('Autchorization') if (!auth) return res.send('no auth') if (!auth.indexOf('Bearer') === -1) res.send('no auth') const token = auth.split('Brarer')[1] const user = JWT.verify(token, 'asdasfgfdghd') if (user.expireAt 密码加密 crypto 库 pbkdf2 密码加密 加密由两个方法 1 同步 2 异步方法实现加密 onst crypto = require('crypto') const pbkdf2Async = require('bluebird').promisify(crypto.pbkdf2)//给回调函数一个异步模块 使用蓝鸟 (async () => { const { username, password } = req.body const cipassword = await crypto.pbkdf2Async(password, 'asdafdsfsdf', 1000, 512, 'sha256') const created = User.insert({ username, password: cipassword }) })() .then(r => {}) .catch(e => {}) 最好密码使用分库分表 不和用户的基本信息在同一个数据库内这样会比较安全 "},"1 Koa/1.4 Koa 集成JWT.html":{"url":"1 Koa/1.4 Koa 集成JWT.html","title":"1.4 Koa 集成JWT","keywords":"","body":"Koa 集成JWT 什么是JWT JWT 即为JSON Web Token的简写目前最流行的跨域认证解决方案。 JWT是通过在用户经过服务器认证后，由服务器发送给客户端一串JSON字符串，而这串字符串内部存储用户的信息，以及登录过期时间等等，在用户在其后的每次请求的请求头中带上这串JWT字符，达到认证的效果。 格式 JSON 数据格式 { \"username\": \"zhangsan\", \"role\": \"user\", \"expiratAt\": \"\" } 字符数据格式 Header.Payload.Signature // 分别是三串加密字符串 请求格式 Authorization: Bearer //注意中间有个空格 Header 格式 { \"alg\": \"HS256\", // 加密方式 默认是hs256 \"typ\": \"JWT\" //令牌类型 } Payload iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 //官方指定的 7个字段 //可以自己定义新的字段不受限制 //JWT 的payload 默认是不加密的 所以不要将敏感数据放在着 Signature 服务器对于JWT的签名，放置JWT被篡改 ，签名需要Header 和Payload 以及一个 服务器的Key 进行加密 HMACSHA256( //默认是 HMACSHA256 加密 base64UrlEncode(header) + \".\" + // 头部 base64UrlEncode(payload), //payload secret) // 加密钥 常见的使用方式 可以存储在 cookie 内部 存储在localstorage 中 使用 cookie 发送 不能跨域 随着 Header 添加字段 Authorization: Bearer //注意中间有个空格 post 请求的时候放在post请求的数据体内 因为Axios 可以设置拦截器与请求头自动 所以常放在Header 中与Axios一起使用 因为JWT 的服务器控制权比较低，也就是令牌发送后服务器就不能确定这个另外的使用者是否更换了，所以过期时间一般设置较短，另外容易发生JWT 被劫持，因此必须配合HTTPS使用。 JWT 建议加密 基础知识 JWT黑名单 客户端要求失效，可以对非正常操作过期时间直接设置为0的方式， 如果token 储存在redis 中，记录uid-time键值对，在redis 中设置黑名单，对于黑名单用户拒绝服务 客户端可以一键设置黑名单 用户重置密码 将token失效。 jwt续签问题，一种解决方式是jwt中存储过期时间，服务端设置刷新时间，请求是判断是否在过期时间或刷新时间，在刷新时间内进行token刷新，而失效token记入黑名单； 而黑名单过大问题，可以采用记录UID-刷新时间方式解决，判断jwt签发时间，jwt签发时间小于UID-刷新时间的记为失效 还可以对用户的短期登录频次以及错误进行记录 实现 自己的代码实现 安装 //安装 base64URl 解析 npm install base64url 生成token const base64UrlEncode = require('base64url') const crypto = require('crypto'); exports.login =async ctx=>{ //过期时间 const expireAt = Date.now() + 24 * 60 * 60 * 1000; const privateKey = fs.readFileSync(\"../private_key.pem\").toString(); //私钥 const header = base64UrlEncode( // header并进行base 64的编码 JSON.stringify({ alg: \"HS256\", typ: \"JWT\" }) ); const payload = base64UrlEncode( // payload 并进行base64 编码 JSON.stringify({ username: ctx.request.body.username, expireAt }) ); const Algorithm = \"SHA256\"; //加密方式 const sign = crypto.createSign(Algorithm); //创建签名 // 使用 update 方法更新数据 sign.update(header + \".\" + payload); // 生成签名 以 hex 格式输入数据 const singniture = sign.sign(privateKey, \"hex\"); //生成token const token = header + \".\" + payload + \".\" + singniture; ctx.set(\"Content-Type\", \"application/json\"); ctx.body = JSON.stringify({ //发送给前端 token, userID: ctx.request.body.username, expireAt }); } 前端接收到token存储 const login = async (user)=>{ const {username,password} = user password = md5(password) // 前端的MD5 加密密码 //登录 const result = await axios.post('localhost:8080/users/login',{ username, password }) //拿到登录成功的result 中的token const {token,userID,expireAt} =result.data //存储到localStorage 中 localStorage.set(\"token\",token) localStorage.set(\"userID\",userID) localStorage.set(\"expireAt\",expireAt) } 前端每次请求都带上token // 这里可以使用axios的全局设置 const AUTH_TOKEN = localStorage.get('token')? \"Bearer \"+localStorage.get('token'):\"\" axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; // 也可以使用拦截器进行个性化设置 例如对于每次的post 提交增加token // 设置可以根据请求的URL 细化 const instance = axios.create({ baseURL: 'https://api.example.com', timeout:1500 }); instance.interceptors.request.use((request)=>{ if(request.method===\"POST\"){ const AUTH_TOKEN = localStorage.get('token')? \"Bearer \"+localStorage.get('token'):\"\" request.headers.common['Authorization'] = AUTH_TOKEN; } return request }) 后端对于token 的验证 后端再次拿到前端的token 主要是为了进行签名验证，查看签名是否被改动过，以及过期时间。 const base64UrlEncode = require(\"base64url\"); const crypto = require(\"crypto\"); const fs = require(\"fs\"); const publicKey = fs.readFileSync(\"./public_key.pem\").toString(); router.all(\"/*\", async (ctx, next) => { const auth = ctx.header.authorization; if (auth) { const Algorithm = \"SHA256\"; // 创建验证 const verify = crypto.createVerify(Algorithm); verify.update(data); //验证签名 const result = verify.verify(publicKey, auth, \"hex\"); if(result){//签名验证通过 // 校验过期时间 const payload = base64UrlEncode.decode(auth.split('.')[1]) if(payload.exp nodejs 使用jsonwebtoken 包 // 加密方法 jwt.sign(payload, secretOrPrivateKey, [options, callback]) //验证方法 jwt.verify(token, secretOrPublicKey, [options, callback]) 加密方法 jwt.sign 第一个参数 载荷 第二个参数 加密方式 或者是字符串 或者是一个key 文件 第三个参数为options 可选 见地址 这些选项可以被签名生成过程时被添加到 payload 和header 中 第四个为callback 接收err 和token //常见用法 exports.login = async ctx=>{ const keyFile =await rs.readFile('../private_key.pem').toString() const payload ={ username, userid, http://foremp.api.com:true } const token = await jwt.sign(payload, keyFile, { expiresIn: '1h', //2h 3days 等等 keyid:111 }) } 验证 jwt.verify 与加密相对应 第一个参数 需要被解密验证的token 第二个参数 加密方式 或者是字符串 或者是一个对应的publickkey 文件 选项 见官方地址 // 使用 var cert = fs.readFileSync('public.pem'); // get public key try{ const decoded = jwt.verify(token, cert, { audience: 'urn:foo', // 验证选项 issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }); }catch(err){ if(err) //如果验证没通过会抛出错误异常 err = { name: 'TokenExpiredError', //过期 message: 'jwt expired', expiredAt: 1408621000 } } jwt.decode(token [, options]) 对token解码 返回值为 字符串状态的 header 和payload 可以自己手动来进行验证。 koa-jwt koa-jwt用来查看请求中是否有token信息的中间件 app.use( jwtKoa({secret: SECRET}) .unless({ path: [/\\/login/] // 不需要通过jwt验证的请求路径 }) ) router.get('/login', async (ctx) => { let token = jwt.sign({ name: 'dva' }, SECRET) console.log(token, 'token') ctx.body = { token } }) router.get('/try', async (ctx) => { let token = ctx.header.authorization let result = jwt.verify(token, SECRET) ctx.body = { result } }) JWT 的常见问题解决 JWT 详细分析 作者：嚣张小飞 jWT白名单 "},"1 Koa/1.5 oAuth2第三方登录.html":{"url":"1 Koa/1.5 oAuth2第三方登录.html","title":"1.5 oAuth2第三方登录","keywords":"","body":"oAuth2 第三方登录 什么是oAuth2 阮一峰 大神的普及 流程 来源于 在GitHub中备案第三方应用，拿到属于它的客户端ID和客户端密钥。   在github-settings-developer settings中创建一个OAuth App。并填写相关内容。填写完成后Github会给你一个客户端ID和客户端密钥。 此时在你的第三方网站就可以提供一个Github登录链接，用户点击该链接后会跳转到Github。这一步拿着客户端ID向Github请求授权码code。 const config = { client_id: '28926186082164bbea8f', client_secret: '07c4fdae1d5ca458dae3345b6d77a0add5a785ca'} router.get('/github/login', async (ctx) => { var dataStr = (new Date()).valueOf(); //重定向到认证接口,并配置参数 var path = \"https://github.com/login/oauth/authorize\"; path += '?client_id=' + config.client_id; //转发到授权服务器 ctx.redirect(path);})复制代码 用户跳转到Github，输入Github的用户名密码，表示用户同意使用Github身份登录第三方网站。此时就会带着授权码code跳回第三方网站。跳回的地址在创建该OAuth时已经设置好了。http://localhost:3000/github/callback 第三方网站收到授权码，就可以拿着授权码、客户端ID和客户端密钥去向Github请求access_token令牌。 Github收到请求，向第三方网站颁发令牌。 第三方网站收到令牌，就可以暂时拥有Github一些请求的权限，比如说拿到用户信息，拿到这个用户信息之后就可以构建自己第三方网站的token，做相关的鉴权操作。 自己实现 google 举例 注册 client_id 你的注册ID redirect_uri 你需要接收数据的地址 url 你的应用地址 response_type 返回类型 code 和token client_secret 客户端密钥 用来给google 发送确认信息返回token的 前端发送链接 const url = \" https://accounts.google.com/o/oauth2/v2/auth? // 这个是请求权限的地址 response_type=code& //返回类型 redirect_uri=http://localhost:4000/authcallback& //接收返回地址 scope=https://www.googleapis.com/auth/userinfo.email& //权限请求范围 client_id=8888888888888888888888888\" 你的client_id google 中转界面 用户在中转界面跳转 后端接收 router.get(\"/authcallback\", async ctx => { // callback 路由获取到code const code = ctx.query.code; // todo }); 后端发送code 给Google并请求用户数据 router.get(\"/authcallback\", async ctx => { // callback 路由获取到code const code = ctx.query.code; const result = await axios.post(\"https://oauth2.googleapis.com/token\", { code,// 上面接收到的code redirect_uri: \"http://localhost:4000/authcallback\", //其实在这一步这个已经没啥用 client_id: //同样 client_id \"*******************.apps.googleusercontent.com\", scope: \"https://www.googleapis.com/auth/userinfo.email\", //范围 client_secret: \"*********************\", // 申请时的密匙 grant_type: \"authorization_code\" }); console.log(result.data); // 返回值就是用户的信息了 // 返回值是一个token 需要使用JWT 解密 }); passport 实现 "},"1 Koa/1.6 防止机器人爬虫.html":{"url":"1 Koa/1.6 防止机器人爬虫.html","title":"1.6 防止机器人爬虫","keywords":"","body":""},"1 Koa/1.7 限制请求-黑名单白名单.html":{"url":"1 Koa/1.7 限制请求-黑名单白名单.html","title":"1.7 限制请求-黑名单白名单","keywords":"","body":""},"1 Koa/1.8 axios的单次发送.html":{"url":"1 Koa/1.8 axios的单次发送.html","title":"1.8 axios的单次发送","keywords":"","body":""},"1 Koa/1.9 二维码.html":{"url":"1 Koa/1.9 二维码.html","title":"1.9 二维码","keywords":"","body":""},"1 Koa/1.10 图片的处理.html":{"url":"1 Koa/1.10 图片的处理.html","title":"1.10 图片的处理","keywords":"","body":""},"1 Koa/1.11 接口防盗.html":{"url":"1 Koa/1.11 接口防盗.html","title":"1.11 接口防盗","keywords":"","body":""},"1 Koa/1.12 加密策略.html":{"url":"1 Koa/1.12 加密策略.html","title":"1.12 加密策略","keywords":"","body":""},"1 Koa/1.13 第三方支付.html":{"url":"1 Koa/1.13 第三方支付.html","title":"1.13 第三方支付","keywords":"","body":""},"1 Koa/1.14 中间层服务端渲染.html":{"url":"1 Koa/1.14 中间层服务端渲染.html","title":"1.14 中间层服务端渲染","keywords":"","body":""},"1 Koa/Koa 中间件.html":{"url":"1 Koa/Koa 中间件.html","title":"Koa 中间件","keywords":"","body":"koa 中间件 Keygrip 一个node.js模块，用于通过轮换凭证系统对数据（如cookie或URL）进行签名和验证，其中可以添加新服务器密钥并定期删除旧服务器密钥，而不会使客户端凭据无效。 html-minifier 缩小html 大小 koa-router 路由 koa-bodyparser 解析post koa-session session 中间件 koa-logger koa 使用日志打印的中间件 "},"2 MongoDB/2.1 MongoDB创建数据库和表.html":{"url":"2 MongoDB/2.1 MongoDB创建数据库和表.html","title":"2.1 MongoDB创建数据库和表","keywords":"","body":"创建数据库和创建表 使用数据库 use 数据库名称 // 使用数据库 创建表 // 插入一条数据的同时就会创建表 db.表名.insert() 删除表 // 删除 表 db.表名.drop() "},"2 MongoDB/2.2 MongooDB基本的CRUD操作 - 副本.html":{"url":"2 MongoDB/2.2 MongooDB基本的CRUD操作 - 副本.html","title":"2.2 MongooDB基本的CRUD操作 - 副本","keywords":"","body":"mongoDB 增删改查 CRUD 操作 增 插入文档 mongo 中提供了三条命令来插入 # 返回 WriteResult 对象 db.collection.insert() #version 3.2新增 插入一条 返回插入数据的 primary key _id objectID db.collection.insertOne() # version 3.2 新增同时插入多条数据 一条失败前面的成功后面的全部失败 db.collection.insertMany({document数组}， {writeConcern ： ， ordered ： 删除方法 db.collection.remove() #删除符合条件的 可由 justone属性指定 删除一条 db.collection.deleteOne()#删除第一条符合条件的 3.2 db.collection.deleteMany() #删除多条条件选中 3.2 查询的方法 {}代表并且条件 ObjectId ObjectId是一个 12 字节 BSON 类型数据，有以下格式： - 前 4 个字节表示时间戳 - 接下来的 3 个字节是机器标识码 - 紧接的两个字节由进程 id 组成（PID） - 最后三个字节是随机数 $ 后面接条件符号 db.user.find({age:12}) # 表明查询年龄等于12岁的 db.user.find({age:{$gt:12}}) # 表明查询年龄大于12岁的 db.user.find({age:{$gt:12，$lt:30}}) # 表明查询年龄大于12岁并且小于30 的 db.user.find({age:{$or：[{$gt:12},{$lt:30}]}}) # 表明查询年龄大于12岁并且小于30 的 db.user.find({age:{$exists:true}}) # 查询年龄字段存在 数组的查询 用：方式表示数组的并行属于 db.user.find({数组;'数组内数据'}) 内嵌对象的查询， 用点的方式 表示内嵌 db.user.find({对象.子对象;'要查询的内容'}) 数组内储存对象 #数组名：[{属性1：值},{},{}] db.user.find({\"数组名:属性1\"：值})可查出 $elemMatch 指定数组内多项条件同时过滤，数组内查询时的并且条件 指定内置数据的位置 db.user.find({ '数组名.下标.属性': '值' }) 正则 ==不推荐== 使用正则筛选一个大体量的数据 db.user.find({name:{\\$regex:\"正则\"}}) $size 查询大小 但是会把数组中含有对象和含有字符串的全部查询出来因此数据的一致性有挑战 find 的第二个参数 显示字段 ```bash db.user.find({条件}，{name:1,age:1}) # 1 显示 0 不显示此字段 ID 要不显示必须手动指定为0，此方法在显示数组内字段会有缺陷 # 这样查询出来的就会值显示其 ID name 和age 三个字段 其他的字段全部隐藏 # 这个可以显示内嵌在对象或者数组中的字段 ``` 查询空字段 如果在 mngodb 中查询某一个字段的值为空的时候需要指定`{ name : { $type: 10 } }`查询 仅仅 匹配那些包含值是 null 的 name 字段的文档,亦即 条目字段的值是 BSON 类型中的 Null (即 10 ): 存在检查 `{ name : { $exists: false } }` 检查是否存在该属性 更改 update 的$set db.user.update({条件}，{name:1,age:1}) # 如果不写$set 会把user的匹配所有字段全部洗掉 变成后面的对象 # 而加入$set后会自动查找匹配的字段 进行替换 update 的 $unset 把字段删除 相当于==删除==某匹配字段 update 的第三个选项 {returnnewdocument：true} {motli:true} db.user.findOneAndupdate({条件}，{name:1,age:1},{new:true}) # {motli:true} 一起处理 多个一起 #returnnewdocument：true 返回更改过后的新文档 # upsert 有就更改 没有就插入 原子性的 # 批量操作 bulkWrite（）方法 在使用的时候由两种模式 有序插入 通过选项 ordered true 默认 无序插入 设置为 ordered false //bulkWrite（）支持以下写操作 // insertOne() // updateOne() // updateMany() // replaceOne() // deleteOne() // deleteMany() //使用方法 try { db.characters.bulkWrite( [ { insertOne : { \"document\" : { \"_id\" : 4, \"char\" : \"Dithras\", \"class\" : \"barbarian\", \"lvl\" : 4 } } }, { updateOne : { \"filter\" : { \"char\" : \"Eldon\" }, \"update\" : { $set : { \"status\" : \"Critical Injury\" } } } }, { deleteOne : { \"filter\" : { \"char\" : \"Brisbane\"} } }, { replaceOne : { \"filter\" : { \"char\" : \"Meldane\" }, \"replacement\" : { \"char\" : \"Tanys\", \"class\" : \"oracle\", \"lvl\" : 4 } } } ] ); } catch (e) { print(e); } 数据结构 浮点数的经度丢失需要使用 decimal格式来处理 ，包括 java 和 c 和 javascript 都在使用而 mongoode 默认就会使用这个格式 ， mongo 可以直接存 js 代码指定其类型 "},"2 MongoDB/2.3 MongooDB索引和权限配置.html":{"url":"2 MongoDB/2.3 MongooDB索引和权限配置.html","title":"2.3 MongooDB索引和权限配置","keywords":"","body":"索引以及权限配置 索引 有索引之后根据索引查询速度会特别快 ，但是插入会很慢，使用空间来换时间，不会读取文档而是读取索引 删除索引查找索引 // 查询索引 db.user.getIndeses() // 查询所有索引 // 删除索引 db.user.dropIndex({\"字段名\"：1}) 新增索引 //1 标识升序索引 -1 标识降序索引 // 设置索引 db.user.ensureIndex({\"字段名称\"：1}) 唯一索引 // 唯一索引 db.user.ensureIndex({\"字段名称\"：1，\"字段名称2\"：-1，}，{unique:true}) # 字段不可以以重复 复合索引 // 设置复合索引 db.user.ensureIndex({\"字段名称\"：1，\"字段名称2\"：-1，}) 语句时间分析 explain(\"executionStats\") //语句执行时间 账户权限配置 管理员用户都在admin 表中 创建管理员 和操作员 mongo ... ... use admin # 创建管理员 db.createUser({user: \"admin\",pwd: \"admin\",roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]}) 退出 然后使用管理员账号重新登录 创建操作员 # 创建数据操作员 db.createUser({user: \"leiyuyang\",pwd: \"leiyuyang\",roles: [ { role: \"readWrite\", db: \"doracms2\" } ]}) 修改配置文件/bin /mongdb.conf 添加在 security: auth：true 如果是在3.x 版本以上添加 security: authorization: \"enabled\" "},"2 MongoDB/2.4 MongooDB聚合管道.html":{"url":"2 MongoDB/2.4 MongooDB聚合管道.html","title":"2.4 MongooDB聚合管道","keywords":"","body":"聚合管道 可以对集合中的文档数据进行变换和组合 // 通过 db.orders.aggregate([ {$match:{username:\"zhangsan\"}}, {$group:{age:30，total：{$sum:'$amount'}}} ]) 上面的代码是先查到 username 是张三的人，然后对所有的张三进行分组 30岁的一组 不是三十的一组，这个操作会返回连个组合 常见的操作符 $project 添加 删除 命名 需要显示的列 $lookup 引入其他集合数据 关联查询 $match 条件匹配 满足条件筛选进入下一组管道 相当于mysql的have $group 条件组合结果 统计 相当于 groupby $sort 条件排序 $skip 跳过 $limit 限制数量 $unwide 拆分数组 $project 管道操作符 db.users.aggregate([{$project:{username:1}}]) // 表示 查找users 表 只显示 username 于find 第二个参数select 使用方式类似 $match 匹配 db.users.aggregate([{$project:{username:1}},{$match:{username:'zhangsan'}}]) // 相当于 db.users.find({username:'zhangsan'},{username:1}) $group 分组 group分组后可以进行统计 db.users.aggregate([ {$project:{username:1}}, {$match:{username:'zhangsan'}}, {$group:{_id:'$username',totle:{$sum:'$age'}}}, //注意 此处有一个再承参数前有一个$ ]) $sort 排序 db.users.aggregate([ {$project:{username:1,age:1}}, {$match:{username:'zhangsan'}}, {$sort:{\"age\":1}} //1 表示正序 -1 表示负序 ]) $limit 限制条数 db.users.aggregate([ {$project:{username:1,age:1}}, {$match:{username:'zhangsan'}}, {$limit:2} // 只返回2条 ]) $skip 跳过几条 db.users.aggregate([ {$project:{username:1,age:1}}, {$match:{username:'zhangsan'}}, {$skip:2} //跳过前两条 ]) $lookup 用于表的关联操作 db.users.aggregate([ { $lookup:{ from:\"context\", // 表示需要于哪个表进行关联 localField:\"userID\"，//表示主查表users 的关联字段 userID foreignField:\"userID\",//表示子表的context的关联字段 userID 这连个字段是相关联但是名称 不一定一样 as:\"items\"}}, //需要把数据放到什么字段内 这样就可以把查询到的数据放到items内 // items 是一个数组 { $match:{ //$lookup 后使用match 对数据继续进行筛选 age:{ $gt:20 } } } ]) "},"2 MongoDB/2.5 MongooDB需要注意的点以及数组内操作.html":{"url":"2 MongoDB/2.5 MongooDB需要注意的点以及数组内操作.html","title":"2.5 MongooDB需要注意的点以及数组内操作","keywords":"","body":"mongoDB 一些特殊的地方 mongdb 中的主键 是由生成时间 自增长的数字 和线程号 机器服务器号组合生成的 mongo 中操作条件 ==就是在当前的数据解构中再加一层括号== mongo 中有几种层级 db 库 collection 表 document 文档级别 也就是一次时候输入操作在 insert 语句括号中的整个插入对象 mongodb 事物 支持不友好,需要做两次操作的时候,要自己实现事物，mongodb 的插入原子性都是基于方法来实现的 mongodb 主键 为_id默认的 在查询字段的时候建议使用$ in 而不是$or 返回指定数组 $elemMatch ， $slice，以及$ 是用来指定返回==数组== 唯一 方式。不能使用数组索引来指定映射的特定数组元素； 例如: db.users.find( { status: \"A\" }, { name: 1, status: 1, points: { $slice: -1 } } ) // 可以返回status 为A的 points数组中的的最后一个元素 db.users.find( {} , \"ratings.0\": 1 }) // 映射不会映射到数组的第一个元素，这样写不对。 db.users.find( { \"badges.0\": \"black\" } ) //可以得到数组一个属性时black的 也就是说$elemMatch ， $slice ，以及 $ 操作的是数组内映射关系，数组内元素关系 . 而不用这个几个操作符的时候，操作的是数组名称 "},"2 MongoDB/2.6 MongoDB的服务器配置.html":{"url":"2 MongoDB/2.6 MongoDB的服务器配置.html","title":"2.6 MongoDB的服务器配置","keywords":"","body":"CentOS 部署 MongoDB 安装过程 添加 MongoDB 的源： mongodb-org 这个包默认不存在 CentOS 的源里，所以要先添加到我们服务器中： vi /etc/yum.repos.d/mongodb-org.repo 然后访问 Install on Red Hat 找到最新的 MongoDB 稳定版本并添加到上面打开的文档中，类似这样： [mongodb-org-4.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc [mongodb-org-3.6] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc [mongodb-org-3.4] name=MongoDB 3.4 Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/ gpgcheck=0 enabled=1 编辑并保存文件，查看服务器源列表中是否已添加成功（留意 mongodb-org-版本）： $ yum repolist # 输出一般如下 . . . repo id repo name base/7/x86_64 CentOS-7 - Base extras/7/x86_64 CentOS-7 - Extras mongodb-org-3.2/7/x86_64 MongoDB Repository updates/7/x86_64 CentOS-7 - Updates . . . 安装 MongoDB： yum install mongodb-org 启动 MongoDB： $ sudo systemctl start mongod 如有需要重新解析改动后的 /etc/mongod.conf 配置文件，可以执行： $ sudo systemctl reload mongod 因为 systemctl 并不返回启动结果，所以可以通过以下命令查看是否启动： $ sudo tail /var/log/mongodb/mongod.log 查找是否包含该日志，若出现则表示服务已启动，可以通过 mongo 来开启命令： . . . [initandlisten] waiting for connections on port 27017 开机自启动 首先查看是否已启用： $ systemctl is-enabled mongod; echo $? # 查看输出是否包含 enabled 字样 . . . enabled 0 若无，可以手动启动： $ sudo systemctl enable mongod 导入 example 数据 mongorestore -h 127.0.0.1:27017 -d doracms2 --drop #centos上要引入的数据的目录 创建管理员 和操作员 mongo ... ... use admin # 创建管理员 db.createUser({user: \"admin\",pwd: \"admin\",roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]}) 退出 然后使用管理员账号重新登录 创建操作员 # 创建数据操作员 db.createUser({user: \"leiyuyang\",pwd: \"leiyuyang\",roles: [ { role: \"readWrite\", db: \"doracms2\" } ]}) 修改配置文件 mongdb.conf 添加在 security: auth：true 如果是在3.x 版本以上添加 security: authorization: \"enabled\" 查看数据： $ mongo $ db.restaurants.find() 删除数据库： $ db.restaurants.drop() 数据库权限操作 $ mongo --port 27017 $ use admin $ db.auth(\"root\", \"xxxxxx\") $ show dbs # 查看数据库 $ use # 选择数据库 $ show collections # 查看 collections $ db.collectionName.find() # 查看 documents $ use # 创建数据库 $ db.test.insert({\"name\":\"tutorials point\"}) # 随便插入点数据（才能出现） 添加数据库用户 $ mongo --port 27017 $ use admin $ db.createUser( { user: \"root\", pwd: \"xxxxxx\", roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ] }) # 现在我们为 MongoDB 的 admin 数据库添加一个用户 root，MongoDB 可以为每个数据库 # 都建立权限认证，也就是你可以指定某个用户可以登录到哪个数据库。上面的代码，我们为 # admin 数据库添加了一个 root 用户，在 MongoDB 中 admin 数据库是一个特别的数据库， # 这个数据库的用户，可以访问 Mongodb 中的所有数据库。 用户登录 # 方式一 $ mongo --port 27017 -u \"root\" -p \"xxxxxx\" --authenticationDatabase \"admin\" # 方式二 $ mongo --port 27017 $ use admin $ db.auth(\"root\", \"xxxxxx\") // 输出 1 表示验证成功，并且不会报错了 账户相关操作： # 查询某个数据库下用户（每个数据库的用户账号都是以文档形式存储在 system.users 集合里面的） $ db.system.users.find() # 删除某个数据库下的所有用户 $ db.system.users.remove() # 删除指定用户 $ db.system.users.remove({'user':'用户名'}) # 修改账户密码 db.changeUserPassword(\"username\", \"newpassword\") 数据库数据操作 mongoexport导出表，或者表中部分字段（一般可以简写） $ mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --csv -q 条件 -f 字段 -o newdbexport.json/dat/csv -h：数据库宿主机的IP -u：数据库用户名 -p：数据库密码 -d：数据库名字 -c：集合的名字 -f：导出的列名 -q：导出数据的过滤条件 -o：导出文件的目录及文件名（/xx/xx/xx.json） --type：json 或 csv（默认是 json） 比如导出整张表： $ mongoexport -d test -c users -o allusers.dat 比如导出部分字段： $ mongoexport -d test -c users --csv -f uid,name,sex -o test/users.csv 比如根据条件敢出数据： $ mongoexport -d test -c users -q '{uid:{$gt:1}}' -o test/users.json 导入表 # mongoimport 导入表，或者表中部分字段 $ mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 比如还原导出的表数据（--upsert 插入或者更新现有数据） $ mongoimport -d test -c users --upsert test/users.dat 比如部分字段的表数据导入（--upsertFields根--upsert一样） $ mongoimport -d test -c users --upsertFields uid,name,sex test/users.dat 比如还原csv文件 $ mongoimport -d test -c users --type csv --headerline --file test/users.csv 备份数据库 # mongodump 备份数据库（如果想导出所有数据库，可以去掉-d） $ mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径 比如： $ mongodump -h 127.0.0.1 -p 30216 -d test -uxxxx -pxxxxx -o home/mongodb/ 还原数据库 # mongorestore 还原数据库 $ mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径 比如： $ mongorestore -d test /home/mongodb/test "},"3 Mongoose/":{"url":"3 Mongoose/","title":"3 Mongoose","keywords":"","body":"mongoose 学习笔记和使用方式 基于网上文档和自己的总结 其中mongoDB的注意点同样适用于mongoose mongoDB的优化同样适用于mongoose mongoDB的 $ 操作符同样适用于mongoose 其他很好的文档 http://laibh.top/2019-03-26-mongoose.html "},"3 Mongoose/3.1 Mongoose安装、创建、连接.html":{"url":"3 Mongoose/3.1 Mongoose安装、创建、连接.html","title":"3.1 Mongoose安装、创建、连接","keywords":"","body":"Mongoose的安装，创建，和连接 安装 首先你必须安装MongoDB和NodeJS 安装nodejs和mongodb之后 ，使用npm来安装mongoose $ npm install mongoose 　　安装成功后，就可以通过 require('mongoose') 来使用 连接数据库 　　使用require()方法在项目中包含mongoose后，接下来使用connect()方法连接到MongoDB数据库 connect() connect()最简单的使用方式，就是只要传入url参数即可，连接到本地localhost的db1服务器 var mongoose = require('mongoose'); //引用mongoose模块 // mongoose.connect('mongodb://localhost/db1') 或者 var db = mongoose.createConnection('localhost','db1'); //创建一个数据库连接 　　 传递用户名、密码 mongoose.connect('mongodb://username:password@host:port/database?options...'); options 　　connect()方法还接受一个选项对象options，该对象将传递给底层驱动程序。这里所包含的所有选项优先于连接字符串中传递的选项 mongoose.connect(uri, options); 　　可用选项如下所示 db -数据库设置 server -服务器设置 replset -副本集设置 user -用户名 pass -密码 auth -鉴权选项 mongos -连接多个数据库 promiseLibrary var options = { db: { native_parser: true }, server: { poolSize: 5 }, replset: { rs_name: 'myReplicaSetName' }, user: 'myUserName', pass: 'myPassword' } mongoose.connect(uri, options); 连接多个数据库 　　如果要连接多个数据库，只需要设置多个url以,隔开，同时设置mongos为true mongoose.connect('urlA,urlB,...', { mongos : true }) 回调 　　connect()函数还接受一个回调参数 mongoose.connect(uri, options, function(error) { }); 　　执行下列代码后，控制台输出“连接成功” var mongoose = require('mongoose'); mongoose.connect(\"mongodb://localhost/test\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); } }); 　　如果开启鉴权控制，以用户名\"u1\"，密码\"123456\"登录'db1'数据库。执行代码后，控制台输出“连接成功” var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); } }); disconnect() mongoose.disconnect() 　　 使用disconnect()方法可以断开连接 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); } }); setTimeout(function(){ mongoose.disconnect(function(){ console.log(\"断开连接\"); }) }, 2000); "},"3 Mongoose/3.10 Mongoose 基于Model的更新操作.html":{"url":"3 Mongoose/3.10 Mongoose 基于Model的更新操作.html","title":"3.10 Mongoose 基于Model的更新操作","keywords":"","body":"基于model的文档更新 　　文档更新可以使用以下几种方法 update()//往上改 updateMany() //改多个 updateOne() //改一个 findByIdAndUpdate() //通过i的查询 然后改 fingOneAndUpdate() //找到一个就改 find() + save()//栈 让然后改 findOne() + save()//找一个改 update() 　　第一个参数conditions为查询条件，第二个参数doc为需要修改的数据，第三个参数options为控制选项，第四个参数是回调函数 Model.update(conditions, doc, [options], [callback]) options有如下选项 safe (boolean)： 默认为true。安全模式。 　　upsert (boolean)： 默认为false。如果不存在则创建新记录。 　　multi (boolean)： 默认为false。是否更新多个查询记录。 　　runValidators： 如果值为true，执行Validation验证。 　　setDefaultsOnInsert： 如果upsert选项为true，在新建时插入文档定义的默认值。 　　strict (boolean)： 以strict模式进行更新。 　　overwrite (boolean)： 默认为false。禁用update-only模式，允许覆盖记录。 　　现在使用update()方法查询age大于20的数据，并将其年龄更改为40岁 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.update({age:{$gte:20}},{age:40},function(err,raw){ //{ n: 1, nModified: 1, ok: 1 } console.log(raw); }) } }); 　　如果要同时更新多个记录，需要设置options里的multi为true。下面将名字中有'a'字符的年龄设置为10岁 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.update({name:/a/},{age: 10},{multi:true},function(err,raw){ //{ n: 2, nModified: 2, ok: 1 } console.log(raw); }) } }); 　　如果设置的查找条件，数据库里的数据并不满足，默认什么事都不发生 temp.update({age:100},{name: \"hundred\"},function(err,raw){ //{ n: 0, nModified: 0, ok: 1 } console.log(raw); }) 　　如果设置options里的upsert参数为true，若没有符合查询条件的文档，mongo将会综合第一第二个参数向集合插入一个新的文档 temp.update({age:100},{name: \"hundred\"},{upsert:true},function(err,raw){ //{ n: 1, nModified: 0,upserted: [ { index: 0, _id: 5972c202d46b621fca7fc8c7 } ], ok: 1 } console.log(raw); }) temp.update({name:/aa/},{age: 0},{upsert:true},function(err,raw){ //{ n: 1, nModified: 0,upserted: [ { index: 0, _id: 5972c288d46b621fca7fdd8f } ], ok: 1 } console.log(raw); }) 　[注意]update()方法中的回调函数不能省略，否则数据不会被更新。如果回调函数里并没有什么有用的信息，则可以使用exec()简化代码 temp.update({name:/aa/},{age: 0},{upsert:true}).exec(); 更新子文档的方法 //这里的第一个要找到子文档的位置 具体到哪一条数据的哪一个子文档 temp.update({\"userid\":userid,\"cartList.productId\":productId}, //这里要更新的属性是 子文档 然后 .$.要更改的属性 ： 值 {cartList.$.productNum:10},[opintion],function(err,doc){ if(err){ res.json({ status: result: msg: }) return } doc...//TODO }) updateMany() 　　updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi:false}也无法只更新第一个文档 Model.updateMany(conditions, doc, [options], [callback]) 　　将数据库中名字中带有'huo'的数据，年龄变为50岁 temp.updateMany({name:/huo/},{age:50},function(err,raw){ //{ n: 2, nModified: 2, ok: 1 } console.log(raw); }); find() + save() 　　如果需要更新的操作比较复杂，可以使用find()+save()方法来处理，比如找到年龄小于30岁的数据，名字后面添加'30'字符 temp.find({age:{$lt:20}},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 10 }, //{ _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 }] console.log(docs); docs.forEach(function(item,index,arr){ item.name += '30'; item.save(); }) //[ { _id: 5971f93be6f98ec60e3dc86d, name: 'wang30', age: 10 }, // { _id: 5971f93be6f98ec60e3dc86f, name: 'li30', age: 12 }] console.log(docs); }); updateOne() 　　updateOne()方法只能更新找到的第一条数据，即使设置{multi:true}也无法同时更新多个文档 　　将数据库中名字中带有'huo'的数据，年龄变为60岁 temp.updateOne({name:/huo/},{age:60},function(err,raw){ //{ n: 1, nModified: 1, ok: 1 } console.log(raw); }); findOne() + save() 　　如果需要更新的操作比较复杂，可以使用findOne()+save()方法来处理，比如找到名字为'huochai'的数据，年龄加100岁 temp.findOne({name:'huochai'},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 10 } console.log(doc); doc.age += 100; doc.save(); //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 110 } console.log(doc); }); findOneAndUpdate() 　　fineOneAndUpdate()方法的第四个参数回调函数的形式如下function(err,doc){} Model.findOneAndUpdate([conditions], [update], [options], [callback]) findByIdAndUpdate 　　 fineByIdAndUpdate()方法的第四个参数回调函数的形式如下function(err,doc){} Model.findOneAndUpdate([conditions], [update], [options], [callback]) Update的更新操作符 \"$inc\"增减修改器,只对数字有效 this.ctx.model.Article.update({\"age\":22}, {$inc:{\"age\":1} } ); 复制代码 找到age=22的文档,修改文档的age值自增1 '$set' 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型 this.ctx.model.Article.update({ _id：5c4a819fb87ba4002a47bc4f }, { $set: { isDelete: true } }); 复制代码 对5c4a819fb87ba4002a47bc4f 表进行软删除，找到特定_id数据，增加或者修改isDelete属性 \"$unset\"同上取反,删除一个键 this.ctx.model.Article.update({age:22}, {$unset:{age:18} } ); 复制代码 执行后age键不存在 '$push'给一个键push一个数组成员,键不存在会创建,对数组有效 this.ctx.model.Article.update({name:'wxw'}, {$push:{array:10} } ); 复制代码 返回Article表中name为wxw的数据，增加一个array键,类型为数组,有一个成员 10 '$addToSet'向数组中添加一个元素,如果存在就不添加 this.ctx.model.Article.update({name:'wxw'},{$addToSet:{array:10} } ); 复制代码 返回Article表中name为wxw的数据，array中有10所以不会添加 '$each'遍历数组和 $push 修改器配合可以插入多个值 this.ctx.model.Article.update({name:'wxw'}, {$push:{array:{$each: [1,2,3,4,5]}} } ); 复制代码 返回Article表中name为wxw的数据，执行后array : [10,1,2,3,4,5] '$pop' 向数组中尾部删除一个元素 this.ctx.model.Article.update({name:'wxw'}, {$pop:{array:1} } ); 复制代码 返回Article表中name为wxw的数据，其中array : [10,1,2,3,4,5]，执行后 array : [10,1,2,3,4] tip:将1改成-1可以删除数组首部元素 '$pull' 向数组中删除指定元素 this.ctx.model.Article.update({name:'wxw'}, {$pull:{array:10} }); 复制代码 返回Article表中name为wxw的数据，匹配到array中的10后将其删除 "},"3 Mongoose/3.11 Mongoose 的自定义方法.html":{"url":"3 Mongoose/3.11 Mongoose 的自定义方法.html","title":"3.11 Mongoose 的自定义方法","keywords":"","body":"Mongoose 自定义方法 实例方法 　　Model的实例是document，内置实例方法有很多，如 save，可以通过Schema对象的methods属性给实例自定义扩展方法 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ num:Number, name: String, size: String }); schema.methods.findSimilarSizes = function(cb){//实例方法 return this.model('MyModel').find({size:this.size},cb); } var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ name:'doc1', size: 'small' }); var doc2 = new MyModel({ name:'doc2', size: 'small' }); var doc3 = new MyModel({ name:'doc3', size: 'big' }); doc1.save(); doc2.save(); doc3.save(); setTimeout(function(){ doc1.findSimilarSizes(function(err,docs){ docs.forEach(function(item,index,arr){ //doc1 //doc2 console.log(item.name) }) }) },0) } }); 静态方法 　　通过Schema对象的statics属性给 Model 添加静态方法 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ num:Number, name: String, size: String }); schema.statics.findByName = function(name,cb){ //静态方法 return this.find({name: new RegExp(name,'i')},cb); } var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ name:'doc1', size: 'small' }); var doc2 = new MyModel({ name:'doc2', size: 'small' }); var doc3 = new MyModel({ name:'doc3', size: 'big' }); doc1.save(); doc2.save(); doc3.save(); setTimeout(function(){ MyModel.findByName('doc1',function(err,docs){ //[ { _id: 5971e68f4f4216605880dca2,name: 'doc1',size: 'small',__v: 0 } ] console.log(docs); }) },0) } }); 　　由上所示，实例方法和静态方法的区别在于，静态方法是通过Schema对象的statics属性给model添加方法，实例方法是通过Schema对象的methods是给document添加方法 查询方法 　　通过schema对象的query属性，给model添加查询方法 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); schema.query.byName = function(name){//查询方法 return this.find({name: new RegExp(name)}); } var temp = mongoose.model('temp', schema); temp.find().byName('huo').exec(function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, // { _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 } ] console.log(docs); }) } }); 注意： 文档中 static methods query 定义的方法中不能使用箭头函数 ,因为箭头函数会导致方法内部的this 指向问题。使得内部的this 不能指向真正的实例 如果使用箭头函数则需要 在 内部直接使用 下面定义好的model来操作 自定义方法必须在导出的model 代码上方否则报错 因为methods方法实际上是实例进行使用的所以应用很少。类似于getter的处境 查询助手query 方法是挂载在 query 上的 必须借助于find（）或者findOne() 等方法 "},"3 Mongoose/3.12 Mongoose的中间件.html":{"url":"3 Mongoose/3.12 Mongoose的中间件.html","title":"3.12 Mongoose的中间件","keywords":"","body":"Mongoose中间件方法 中间件执行时间 前后钩子即pre()和post()方法，又称为中间件，是在执行某些操作时可以执行的函数。中间件在schema上指定，类似于静态方法或实例方法等，可以在数据库执行下列操作时，设置前后钩子 init validate save remove count find findOne findOneAndRemove findOneAndUpdate insertMany update Serial串行 串行使用pre方法，执行下一个方法使用next调用 var schema = new Schema(...); schema.pre('save',function(next){ //做点什么 next(); }); Parallel并行 并行提供更细粒度的操作 var schema = new Schema(...); schema.pre('save',function(next,done){ //下一个要执行的中间件并行执行 next(); doAsync(done); }); 使用场景 复杂的验证 删除有主外关联的doc 异步默认 某个特定动作触发异步任务，例如触发自定义事件和通知 例如，可以用来做自定义错误处理 schema.pre('save',function(next){ var err = new Eerror('some err'); next(err); }); entity.save(function(err){ console.log(err.message); //some err }); pre()前置先执行钩子 　　以find()方法为例，在执行find()方法之前，执行pre()方法 var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); schema.pre('find',function(next){ console.log('我是pre方法1'); next(); }); schema.pre('find',function(next){ console.log('我是pre方法2'); next(); }); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ console.log(docs[0]); }) /* 我是pre方法1 我是pre方法2 { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 } */ post()前置后执行钩子 　　post()方法并不是在执行某些操作后再去执行的方法，==而在执行某些操作前最后执行的方法==，==post()方法里不可以使用next()== var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); schema.post('find',function(docs){ console.log('我是post方法1'); }); schema.post('find',function(docs){ console.log('我是post方法2'); }); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ console.log(docs[0]); }) /* 我是post方法1 我是post方法2 { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 } */ 注意：post 是在某些操作前 最后执行的方法，内部没有next（） 总的执行时间顺序 最先执行 字段的Setter 然后执行 字段的validate 然后执行pre 最后执行post "},"3 Mongoose/3.13 Mongoose的复杂操作.html":{"url":"3 Mongoose/3.13 Mongoose的复杂操作.html","title":"3.13 Mongoose的复杂操作","keywords":"","body":"Mongoose 的复杂操作 Mongoose 内部设置表字段的嵌套 互相嵌套 // 对象嵌套 const postSchema = new Schema({ name: String, // 在这里引用的User 定义type 为ObjectId ref 为User postedBy: {type: mongoose.Schema.Types.ObjectId, ref: 'User'}, //这里和Model同名 dateCreated: Date, comments: [{body:\"string\", by: mongoose.Schema.Types.ObjectId}], }); mongoose.model(\"Post\",postSchema) // 在User 中 // 数组嵌套 const UserSchema =new Schema({ name:String, userID:String, posts:[{ // 在USer 中这样定义Post type: Schema.Types.ObjectId, ref: 'Post' //这里和Model同名 }] }) 互相关联对应 const postSchema = new Schema({ name: String, userID: { type:String }, // 于另外一张表User 字段关联 dateCreated: Date, comments: [{body:\"string\", by: mongoose.Schema.Types.ObjectId}], }); const UserSchema =new Schema({ name:String, userID:String,// 与另外一张表关联 }) Mongoose 连表操作有两种模式 如果两表没有主表内部直接存储子表的字段 而是字段的外键模式，则使用aggregate 如果是子文档 例如存储在主文档的对象或者数组中则使用populate Mongoose内的管道查询 aggregate 类似于mongoDB的管道查询，管道查询对应夺标查询，应用在两张表没有文档内引用但是有对应关系，schema 对应互相关联对应，例如我有两张表 user 和context 两张表 其中 user和context 是一对多关系。 // 在user中 const mongoose = reuqire('mongoose') const Schema =mongoose.Schema const UserSchema = new Schema({ username:String, userID:String }) // contextSchema const ContextSchema = new Schema({ context:String, userID:String }) // 管道查询 const userModel = reuqire('./user') userModel.aggregate([{ //这里 进行管道查询 $lookup:{ //进行 lookup form:\"context\", localField:\"userID\", foreignField:\"userID\", as:\"items\" } }],function(err,doc){ if(err){ throw new Error(err) } console.log(doc) }) mongoose 的其他管道查询参数类似于mongoDB 联表操作population 联表操作population对应 互相嵌套 以类别category和文章post之间的关联为例 category的model如下所示 const mongoose = require('mongoose') const Schema = mongoose.Schema const CategorySchema = new Schema( { number: { type: Number, required: true, index: true, unique: true, min:[1000000000, '位数不足'], max: [9999999999, '位数过长'] }, name: { type: String, required: true, validate: { validator: (v) => v.trim().length, message: '名称不能为空'} }, description: { type: String }, posts: [{ type: Schema.Types.ObjectId, ref: 'Post' }],// 子表直接嵌入在数组中 recommend: { type: Boolean }, index: { type: Number } }, { timestamps: true } ) module.exports = mongoose.model('Category', CategorySchema) post的model const mongoose = require('mongoose') const Schema = mongoose.Schema const PostSchema = new Schema( { title: { type: String, required: true, unique: true }, description: { type: String }, content: { type: String }, category: { type: Schema.Types.ObjectId, ref: 'Category', index: true },//对象模式 comments: [{ type: Schema.Types.ObjectId, ref: 'Comment' }], //数组模式子文档 likes: [{ type: Schema.Types.ObjectId, ref: 'Like' }],//数组模式子文档 imgUrl: { type: String }, recommend: { type: Boolean }, index: { type: Number } }, { timestamps: true } ) module.exports = mongoose.model('Post', PostSchema) 　　在对类别的操作中， 都需要使用populate操作符显示出所包括的posts中的title /* 加载所有类别 */ app.get('/categories', (req, res) => { // 父 表主查寻 populate 子表的字段 // select 限制返回显示的字段 Category.find().populate('posts','title').select(\"number name description recommend index\").exec((err, docs) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) return res.status(200).json({code: 1, message: '获取类别成功', result: {docs}}) }) }) /* 新增一个类别 */ app.post('/categories', adminAuth, (req, res) => { //创建一个新的父表对象实体 new Category(req.body).save((err, doc) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) // doc 连接到子表 path 子表的表名 ，select 表明连接的字段 doc.populate({path:'posts',select:'title'}, (err, doc) => { if (err) return res.status(500).json({code:0, message: err.message, err}) return res.status(200).json({code: 1, message: '新增成功', result: {doc}}) }) }) }) ... 　　在对文章的操作中，则需要显示出类别category的number属性 /* 按照id加载一篇文章 */ app.get('/posts/:id', (req, res) => { // 主表post 连接到 category显示number Post.findById(req.params.id).populate('category','number').exec((err, doc) => { if (err) return res.status(500).json({code:0, message:err.message, err}) if (doc === null) return res.status(404).json({code:0, message:'文章不存在'}) return res.status(200).json({code:1, message:'获取文章成功', result:{doc}}) }) }) /* 加载所有文章 */ app.get('/posts', (req, res) => { Post.find().select(\"title likes comments recommend imgUrl index\").populate('category','number').sort(\"-createdAt\").exec((err, docs) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) return res.status(200).json({code: 1, message: '获取文章成功', result: {docs}}) }) 　　在新增、更新和删除文章的操作中，都需要重建与category的关联 // 关联category的posts数组 fnRelatedCategory = _id => { Category.findById(_id).exec((err, categoryDoc) => { if (err) return res.status(500).json({ code: 0, message: err.message, err }) if (categoryDoc === null) return res.status(404).json({code:0, message:'该类别不存在，请刷新后再试'}) Post.find({ category: _id }).exec((err, postsDocs) => { if (err) return res.status(500).json({ code: 0, message: err.message, err }) categoryDoc.posts = postsDocs.map(t => t._id) categoryDoc.save(err => { if (err) return res.status(500).json({ code: 0, message: err.message, err }) }) }) }) } /* 按照id更新一篇文章 */ app.put('/posts/:id', adminAuth, (req, res) => { Post.findById(req.params.id).exec((err, doc) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) if (doc === null) return res.status(404).json({code: 0, message: '文章不存在，请刷新后再试'}) for (prop in req.body) { doc[prop] = req.body[prop] } doc.save((err) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) doc.populate({path:'category',select:'number'}, (err, doc) => { if (err) return res.status(500).json({code:0, message: err.message, err}) fnRelatedCategory(doc.category._id) return res.status(200).json({code: 1, message: '更新成功', result: {doc}}) }) }) }) }) ... 数组内部嵌套查询 const UserSchema = new Schema({ userName:{ type:String, required:true }, password:{ type:String, required }, post:[{ type:Schema.Types.ObjectID, ref:\"Post }] }) const PostSchema = new Schema({ title:{ type:String, required:true }, conetxt:{ type:String, required }, auther:{ type:Schema.Types.ObjectID, ref:'User' } }) const User = mongoose.model('User',UserSchema) const Post = mongoose.model('Post',PostSchema) const findUserPost = async (username,title)=>{ return User.findOne({ username, \"post.title\":title // post.title 数组的字段名称 和 查询的对应字段 // 注意这里的字段名最好使用 双引号 要不然可能会出现意向不到的错误 }).exec() } //当然你也可以这样 分步查询 const findUserPost = async (username,title)=>{ const newUser =await User.findOne({ username }).exec() const posts =await Post.find({ auther:newUser._id, title }).exec() return posts } 数组内部的更新 //还是以上面的Schema 为例 // 当需要更新用户的文章的时候 1 需要先找到对应用户 2 然后再更新其文章修改 const UpdateUserPost = async (username,title,newPostContent) =>{ return User.update({ // 查询到文章 username, \"post.title\":title },{ $set: // 进行更新 使用 $ 占位表示对数组内部的字段进行更新 { \"post.$.conetxt\":newPostContent} }).exec() } // 当然你也可以使用如下的分布式操作 const UpdateUserPost = async (username,title,newPostContent) =>{ const user =await User.findOne({ username }).exec() return Post.update({ auther:user._id, title },{ $set: { conetxt:newPostContent} }).exec() } 数组内部的添加和删除 添加 // 添加User的同时 即可 添加post const inserUser = async (newUser) =>{ const user = new User(newUser) user.save() } 删除 const delUser = async (userID)=>{ // 先删除User 对应的所有文章 然后再删除User const result = await Post.remove({ auther:userID }) const result = await User.findByidAndRemove(userID) } 注意 ：上面的逻辑对于一般性的操作还可以，可是对于严格操作数据就可能不会有一致性了 事物的支持 mongoDB 再4.0 后正式支持事物，mongoose 也开始支持事物了 //仍然使用上面的 Schema const demo = async () => { // 获取事物 const session = mongoose.startSession() //操作前开启事物 session.startTransaction() try { const user = new User({firstName: 'alfieri'}) const result = await user.save().session(session) //保存操作 await User.findOneAndUpdate({_id: result._id}, { $inc: { lastName: 'chou'}}).session(session) //更新操作 // 完成全部操作后 提交事物 await session.commitTransaction() //关闭事物 session.endSession() return user // 返回结果 } catch (err) { // 事物异常回滚 await session.abortTransaction() //关闭事物 session.endSession() //提示错误操作 throw new Error('something went wrong') } } 其他例子请看官方示例 对象内部的CRUD 对象内部的crud 使用 字段名.内部字段名的方式 Post.findOne({\"user.username\":'haha'}) //查询 Post.update({\"user.username\":'haha'},{$set{\"user.username\":\"zhangsan\"}}) //更新 "},"3 Mongoose/3.2 Mongoose的初步理解和简化流程.html":{"url":"3 Mongoose/3.2 Mongoose的初步理解和简化流程.html","title":"3.2 Mongoose的初步理解和简化流程","keywords":"","body":"Mongoose的初步理解和简化流程 名词解释 Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力，用于定义数据库的结构。类似创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection。 Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对象，可以对数据库进行增删查改。Model的每一个实例（instance）就是一个文档document Entity（document） ： 由Model创建的实体，他的操作也会影响数据库 注意：Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity`更具操作性。 特点 Mongoose是NodeJS的驱动，不能作为其他语言的驱动。Mongoose有两个特点 　　1、通过关系型数据库的思想来设计非关系型数据库 　　2、基于mongodb驱动，简化操作 　　 简化流程 安装mongoose 引入mongoose 创建连接 定义一个Schema var PersonSchema = new mongoose.Schema({ name:String //定义一个属性name，类型为String }); 将该Schema发布为Model var PersonModel = db.model('Person',PersonSchema); //如果该Model已经发布，则可以直接通过名字索引到，如下： //var PersonModel = db.model('Person'); //如果没有发布，上一段代码将会异常 用Model创建Entity var personEntity = new PersonModel({name:'Krouky'}); //打印这个实体的名字看看 console.log(personEntity.name); //Krouky 我们甚至可以为此Schema创建方法 //为Schema模型追加speak方法 PersonSchema.methos.speak = function(){ console.log('我的名字叫'+this.name); } var PersonModel = db.model('Person',PersonSchema); var personEntity = new PersonModel({name:'Krouky'}); personEntity.speak();//我的名字叫Krouky Entity是具有具体的数据库操作CRUD的 personEntity.save(); //执行完成后，数据库就有该数据了 如果要执行查询，需要依赖Model，当然Entity也是可以做到的 PersonModel.find(function(err,persons){ //查询到的所有person }); "},"3 Mongoose/3.3 Mongoose的Schema、modle、document.html":{"url":"3 Mongoose/3.3 Mongoose的Schema、modle、document.html","title":"3.3 Mongoose的Schema、modle、document","keywords":"","body":"Mongoose的Schema、modle、document Schema 我理解Schema仅仅只是一断代码，他书写完成后程序依然无法使用，更无法通往数据库端，他仅仅只是数据库模型在程序片段中的一种表现，或者是数据属性模型，Schema主要用于定义MongoDB中集合Collection里文档document的结构类型。　 // schema 是一个数据结构的范式 var mongoose = require('mongoose'); var Schema = mongoose.Schema; var mySchema = new Schema({ title: String, author: String, body: String, comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number } }); types String 字符串 Number 数字 Date 日期 Buffer 二进制 Boolean 布尔值 Mixed 混合类型 ObjectId 对象ID 主键 Array 数组 _fk:Schema.Types.ObjectId, //外键 [String] 数组[Number],[Date],[Buffer],[Boolean],Schema.Types.Mixed],[Schema.Types.ObjectId] [注意]创建Schema对象时，声明字段类型有两种方法，一种是首字母大写的字段类型，另一种是引号包含的小写字段类型 var mySchema = new Schema({title:String, author:String}); //或者 var mySchema = new Schema({title:'string', author:'string'}); 　　如果需要在Schema定义后添加其他字段，可以使用add()方法 var MySchema = new Schema; MySchema.add({ name: 'string', color: 'string', price: 'number' }); timestamps 　　在schema中设置timestamps为true，schema映射的文档document会自动添加createdAt和updatedAt这两个字段，代表创建时间和更新时间 var UserSchema = new Schema( {...}, { timestamps: true } ); _id 　　每一个文档document都会被mongoose添加一个不重复的_id，_id的数据类型不是字符串，而是ObjectID类型。如果在查询语句中要使用_id，则需要使用findById语句，而不能使用find或findOne语句 const mongoose = require('mongoose'); const ObjectId = mongoose.Schema.Types.ObjectId; const StudentSchema = new Schema({}); //默认会有_id:ObjectId const TeacherSchema = new Schema({id:ObjectId});//只有id:ObjectId Array Array在JavaScript编程语言中并不是数组，而是集合，因此里面可以存入不同的值，以下代码等价： const Schema1 = new Schema({array:[]}); const Schema2 = new Schema({array:Array}); const Schema3 = new Schema({array:[Schema.Types.Mixed]}); const Schema4 = new Schema({array:[{}]}); Mixed Schema.Types.Mixed是Mongoose定义个混合类型，该混合类型如果未定义具体形式。因此,如果定义具体内容，就直接使用{}来定义，以下两句等价 const AnySchema = new Schema({any:{}}); const AnySchema = new Schema({any:Schema.Types.Mixed}); 混合类型因为没有特定约束，因此可以任意修改，一旦修改了原型，则必须调用markModified() person.anything = {x:[3,4,{y:'change'}]} person.markModified('anything');//传入anything，表示该属性类型发生变化 person.save(); 预定义模式修饰符 在配置Schema的时候使用， trim 自动去掉空格 前后 UpperCase lowerCase 自定义模式修饰符 还可以使用Getters 和Setters 来进行处理 setters 将在数据进入数据库前的时候对数据进行加工 （强烈建议使用）包括查询 插入更新 删除都会触发这个方法 getters 将在数据获取的时候对数据进行加工 （不建议使用）因为只有实体才能使用这个 　　 const UserSchema = new Schema({ username:{ type:String, required:true, set(params){ //进行格式处理 // 添加数据的时候对username这个字段进行处理 //set 函数要求 必须返回一个值 //返回的 值则是真正储存在数据库中的值 //set 函数不允许异步 }, get(){//这个方法是在获取实例数据的时候对数据进行格式化 //const user =new UserModel（{}） //user.find() //只有在user 实例上才能触发这个方法 所以几乎不用 } } }) getter 和setter 函数在nodejs 中本质上不允许异步 设置索引 Schema 初始化可以给表字段增加索引 // 普通索引 const UserSchema = new Schema({ username:{ type:String, required:true, index：true,//设置成普通索引 unique:true //唯一索引 } }) 旨在需要的时候对字段设置索引 所以会导致表空间变大 会导致增加变慢 Model Model模型，是经过Schema构造来的，除了Schema定义的数据库骨架以外，还具有数据库行为模型，他相当于管理数据库属性、行为的类，通过Model可以实例化出文档对象document，文档document的创建和检索都需要通过模型Model来处理 model() mongoose.model() 　　使用model()方法，将Schema编译为Model.model()方法的第一个参数是模型名称 　[注意]一定要将model()方法的第一个参数和其返回值设置为相同的值，否则会出现不可预知的结果 　 　　Mongoose会将集合名称设置为模型名称的小写版。如果名称的最后一个字符是字母，则会变成复数；如果名称的最后一个字符是数字，则不变；如果模型名称为\"MyModel\"，则集合名称为\"mymodels\"；如果模型名称为\"Model1\"，则集合名称为\"model1\" var schema = new mongoose.Schema({ num:Number, name: String, size: String}); var MyModel = mongoose.model('MyModel', schema); var tank = {name:'zhangsan',num:1,size:'large'}; MyModel.create(tank); 你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。 //通过Model创建Entity var tankEntity = new TankModel('someother','size:big'); tankEntity.save(); 实例化文档document(entiry) 　　通过对原型Model1使用new方法，实例化出文档document对象 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); var schema = new mongoose.Schema({ num:Number, name: String, size: String}); var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ size: 'small' }); console.log(doc1.size);//'small' } }); 文档保存 　　通过new Model1()创建的文档doc1，必须通过save()方法，才能将创建的文档保存到数据库的集合中，集合名称为模型名称的小写复数版 　　回调函数是可选项，第一个参数为err，第二个参数为保存的文档对象 save(function (err, doc) {}) var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ num:Number, name: String, size: String }); var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ size: 'small' }); doc1.save(function (err,doc) { //{ __v: 0, size: 'small', _id: 5970daba61162662b45a24a1 } console.log(doc); }) } }); 　　 "},"3 Mongoose/3.4 Mongoose Schema的类型校验.html":{"url":"3 Mongoose/3.4 Mongoose Schema的类型校验.html","title":"3.4 Mongoose Schema的类型校验","keywords":"","body":"Mongoose Schema的文档验证 　　为什么需要文档验证呢？以一个例子作为说明，schema进行如下定义 var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); 　　如果不进行文档验证，保存文档时，就可以不按照Schema设置的字段进行设置，分为以下几种情况 缺少字段的文档可以保存成功 var temp = mongoose.model('temp', schema); new temp({age:10}).save(function(err,doc){ //{ __v: 0, age: 10, _id: 597304442b70086a1ce3cf05 } console.log(doc); }); 包含未设置的字段的文档也可以保存成功， 未设置的字段不被保存 new temp({age:100,abc:\"abc\"}).save(function(err,doc){ //{ __v: 0, age: 100, _id: 5973046a2bb57565b474f48b } console.log(doc); }); 包含字段类型与设置不同的字段的文档也可以保存成功， 不同字段类型的字段被保存为设置的字段类型 new temp({age:true,name:10}).save(function(err,doc){ //{ __v: 0, age: 1, name: '10', _id: 597304f7a926033060255366 } console.log(doc); }); 　　而通过文档验证，就可以避免以下几种情况发生 规则 数据的存储是需要验证的，不是什么数据都能往数据库里丢或者显示到客户端的，数据的验证需要记住以下规则： 验证始终定义在SchemaType中 验证是一个内部中间件 验证是在一个Document被保存时默认启用的，除非你关闭验证 验证是异步递归的，如果你的SubDoc验证失败，Document也将无法保存 验证并不关心错误类型，而通过ValidationError这个对象可以访问 格式 {name: {type:String, validator:value}} 　　常用验证包括以下几种 required: 数据必须填写 default: 默认值 validate: 自定义匹配 min: 最小值(只适用于数字) max: 最大值(只适用于数字) match: 正则匹配(只适用于字符串) enum: 枚举匹配(只适用于字符串) required 　　将age设置为必填字段，如果没有age字段，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:{type:Number,required:true}, name: String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:\"abc\"}).save(function(err,doc){ //Path `age` is required. console.log(err.errors['age'].message); }); default 　　设置age字段的默认值为18，如果不设置age字段，则会取默认值 var schema = new mongoose.Schema({ age:{type:Number,default:18}, name:String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'a'}).save(function(err,doc){ //{ __v: 0, name: 'a', _id: 59730d2e7a751d81582210c1, age: 18 } console.log(doc); }); min | max 　　将age的取值范围设置为[0,10]。如果age取值为20，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:{type:Number,min:0,max:10}, name: String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({age:20}).save(function(err,doc){ //Path `age` (20) is more than maximum allowed value (10). console.log(err.errors['age'].message); }); match 　　将name的match设置为必须存在'a'字符。如果name不存在'a'，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:Number, name:{type:String,match:/a/},x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'bbb'}).save(function(err,doc){ //Path `name` is invalid (bbb). console.log(err.errors['name'].message); }); enum 　　将name的枚举取值设置为['a','b','c']，如果name不在枚举范围内取值，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:Number, name:{type:String,enum:['a','b','c']},x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'bbb'}).save(function(err,doc){ //`bbb` is not a valid enum value for path `name`. console.log(err.errors['name'].message); }); validate 　　validate实际上是一个函数，函数的参数代表当前字段，返回true表示通过验证，返回false表示未通过验证。利用validate可以自定义任何条件。比如，定义名字name的长度必须在4个字符以上 var validateLength = function(arg，err){ //validate:[validator,err] //validator是一个验证函数，err是验证失败的错误信息 if(arg.length > 4){ return true; } err.message='长度不对' return false; }; var schema = new mongoose.Schema({ name:{type:String,validate:validateLength}, age:Number,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'abc'}).save(function(err,doc){ //Validator failed for path `name` with value `abc` console.log(err.errors['name'].message); }); 验证失败 如果验证失败，则会返回err信息，err是一个对象该对象属性如下 err.errors //错误集合（对象） err.errors.color //错误属性(Schema的color属性) err.errors.color.message //错误属性信息 err.errors.path //错误属性路径 err.errors.type //错误类型 err.name //错误名称 err.message //错误消息 一旦验证失败，Model和Entity都将具有和err一样的errors属性 可以从回调函数中接收err 信息 "},"3 Mongoose/3.5 Schema的配置项.html":{"url":"3 Mongoose/3.5 Schema的配置项.html","title":"3.5 Schema的配置项","keywords":"","body":"Schema的配置项 虚拟属性 Schema中如果定义了虚拟属性，那么该属性将不写入数据库，例如： var PersonSchema = new Schema({ name:{ first:String, last:String } }); var PersonModel = mongoose.model('Person',PersonSchema); var krouky = new PersonModel({ name:{first:'krouky',last:'han'} }); 如果每次想使用全名就得这样 console.log(krouky.name.first + ' ' + krouky.name.last); 显然这是很麻烦的，我们可以定义虚拟属性： PersonSchema.virtual('name.full').get(function(){ return this.name.first + ' ' + this.name.last; }); 那么就能用krouky.name.full来调用全名了，反之如果知道full，也可以反解first和last属性 PersonSchema.virtual('name.full').set(function(name){ var split = name.split(' '); this.name.first = split[0]; this.name.last = split[1]; }); var PersonModel = mongoose.model('Person',PersonSchema); var krouky = new PersonModel({}); krouky.name.full = 'krouky han';//会被自动分解 console.log(krouky.name.first);//krouky 配置项 在使用new Schema(config)时，我们可以追加一个参数options来配置Schema的配置，形如： var ExampleSchema = new Schema(config,options); 或者使用 var ExampleSchema = new Schema(config); ExampleSchema.set(option,value); 可供配置项有：safe、strict、capped、versionKey、autoIndex safe——安全属性（默认安全） 一般可做如下配置： new Schema({...},{safe:true}); 当然我们也可以这样 new Schema({...},{safe:{j:1,w:2,wtimeout:10000}}); j表示做1份日志，w表示做2个副本（尚不明确），超时时间10秒 strict——严格配置（默认启用） 确保Entity的值存入数据库前会被自动验证，如果你没有充足的理由，请不要停用，例子： var ThingSchema = new Schema({a:String}); var ThingModel = db.model('Thing',SchemaSchema); var thing = new Thing({iAmNotInTheThingSchema:true}); thing.save();//iAmNotInTheThingSchema这个属性将无法被存储 如果取消严格选项，iAmNotInTheThingSchema将会被存入数据库 该选项也可以在构造实例时使用，例如： var ThingModel = db.model('Thing'); var thing1 = new ThingModel(doc,true); //启用严格 var thing2 = new ThingModel(doc,false); //禁用严格 注意：strict也可以设置为throw，表示出现问题将会抛出错误 shardKey 需要mongodb做分布式，启用该属性会获取到共享KEY capped——上限设置 如果有数据库的批量操作，该属性能限制一次操作的量，例如： new Schema({...},{capped:1024}); //一次操作上线1024条数据 当然该参数也可是JSON对象，包含size、max、autiIndexId属性 new Schema({...},{capped:{size:1024,max:100,autoIndexId:true}}); versionKey——版本锁 版本锁是Mongoose默认配置（__v属性）的，如果你想自己定制，如下： new Schema({...},{versionKey:'__someElse'}); 此时存入数据库的版本锁就不是__v属性，而是__someElse，相当于是给版本锁取名字。 具体怎么存入都是由Mongoose和MongoDB自己决定，当然，这个属性你也可以去除 new Schema({...},{versionKey:false}); 除非你知道你在做什么，并且你知道这样做的后果 autoIndex——自动索引 默认开启 "},"3 Mongoose/3.6  Mongoose 基于DOC（实体）的CRUD.html":{"url":"3 Mongoose/3.6  Mongoose 基于DOC（实体）的CRUD.html","title":"3.6  Mongoose 基于DOC（实体）的CRUD","keywords":"","body":"Mongoose 基于DOC（实体）的CRUD Mongoose 有两种CRUD方式 基于文档的操作 需要实例操作 基于model的操作 只需要通过medel来操作即可 基于Entity的操作 Document的`CRUD都必须经过严格验证的，即Schema的strict严格配置 更新 有许多方式来更新文件，以下是常用的传统方式： PersonModel.findById(id,function(err,person){ person.name = 'MDragon'; person.save(function(err){}); }); 这里，利用Model模型查询到了person对象，该对象属于Entity，可以有save操作，如果使用Model`操作，需注意： PersonModel.findById(id,function(err,person){ person.name = 'MDragon'; var _id = person._id; //需要取出主键_id delete person._id; //再将其删除 PersonModel.update({_id:_id},person,function(err){}); //此时才能用Model操作，否则报错 }); update第一个参数是查询条件，第二个参数是更新的对象，但不能更新主键，这就是为什么要删除主键的原因。 当然这样的更新很麻烦，可以使用$set属性来配置，这样也不用先查询，如果更新的数据比较少，可用性还是很好的： PersonModel.update({_id:_id},{$set:{name:'MDragon'}},function(err){}); 需要注意，Document的CRUD操作都是异步执行，callback第一个参数必须是err，而第二个参数各个方法不一样，update的callback第二个参数是更新的数量，如果要返回更新后的对象，则要使用如下方法 Person.findByIdAndUpdate(_id,{$set:{name:'MDragon'}},function(err,person){ console.log(person.name); //MDragon }); 类似的方法还有findByIdAndRemove，如同名字，只能根据id查询并作update/remove操作，操作的数据仅一条 新增 如果是Entity，使用save方法，如果是Model，使用create方法 //使用Entity来增加一条数据 var krouky = new PersonModel({name:'krouky'}); krouky.save(callback); //使用Model来增加一条数据 var MDragon = {name:'MDragon'}; PersonModel.create(MDragon,callback); 两种新增方法区别在于，如果使用Model新增时，传入的对象只能是纯净的JSON对象，不能是由Model创建的实体，原因是：由Model创建的实体krouky虽然打印是只有{name:'krouky'}，但是krouky属于Entity，包含有Schema属性和Model数据库行为模型。如果是使用Model创建的对象，传入时一定会将隐藏属性也存入数据库，虽然3.x追加了默认严格属性，但也不必要增加操作的报错 删除 和新增一样，删除也有2种方式，但Entity和Model都使用remove方法 基于Entity的子文档操作 如同SQL数据库中2张表有主外关系，Mongoose将2个Document的嵌套叫做Sub-Docs（子文档） 简单的说就是一个Document嵌套另外一个Document或者Documents: var ChildSchema1 = new Schema({name:String}); var ChildSchema2 = new Schema({name:String}); var ParentSchema = new Schema({ children1:ChildSchema1, //嵌套Document children2:[ChildSchema2] //嵌套Documents }); Sub-Docs享受和Documents一样的操作，但是Sub-Docs的操作都由父类去执行 var ParentModel = db.model('Parent',parentSchema); var parent = new ParentModel({ children2:[{name:'c1'},{name:'c2'}] }); parent.children2[0].name = 'd'; parent.save(callback); parent在执行保存时，由于包含children2，他是一个数据库模型对象，因此会先保存chilren2[0]和chilren2[1]。 如果子文档在更新时出现错误，将直接报在父类文档中，可以这样处理： ChildrenSchema.pre('save',function(next){ if('x' === this.name) return next(new Error('#err:not-x')); next(); }); var parent = new ParentModel({children1:{name:'not-x'}}); parent.save(function(err){ console.log(err.message); //#err:not-x }); 查询子文档 如果children是parent的子文档，可以通过如下方法查询到children var child = parent.children.id(id); 新增、删除、更新 子文档是父文档的一个属性，因此按照属性的操作即可，不同的是在新增父类的时候，子文档是会被先加入进去的。 如果ChildrenSchema是临时的一个子文档，不作为数据库映射集合，可以这样： var ParentSchema = new Schema({ children:{ name:String } }); //其实就是匿名混合模式 "},"3 Mongoose/3.7 Mongoose基于Model的查询操作.html":{"url":"3 Mongoose/3.7 Mongoose基于Model的查询操作.html","title":"3.7 Mongoose基于Model的查询操作","keywords":"","body":"基于Model的文档查询 　　使用Mongoose来查找文档很容易，有以下3种方法可供选择 find() findById() findOne() find() 　　第一个参数表示查询条件，第二个参数用于控制返回的字段 selection，第三个参数用于配置查询参数，第四个参数是回调函数，回调函数的形式为function(err,docs){} Model.find(conditions, [projection], [options], [callback]) 　　现在，使用find()方法找出所有数据 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, //{ _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 18 }, //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }, //{ _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 } ] console.log(docs); }) } }); 　　找出年龄大于18的数据 temp.find({age:{$gte:18}},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, //{ _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 18 }, //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }] console.log(docs); }) 　　找出年龄大于18且名字里存在'huo'的数据 temp.find({name:/huo/,age:{$gte:18}},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }] console.log(docs); }) 　　找出名字里存在'a'的数据，且只输出'name'字段 [注意] :_id字段默认输出 temp.find({name:/a/},'name',function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai' }, //{ _id: 5971f93be6f98ec60e3dc86d, name: 'wang' } ] console.log(docs); }) 　　如果确实不需要_id字段输出，可以进行如下设置 temp.find({name:/a/},{name:1,_id:0},function(err,docs){ //[ { name: 'huochai' }, { name: 'wang' } ] console.log(docs); }) 　　找出跳过前两条数据的其他所有数据 [注意]如果使用第三个参数，前两个参数如果没有值，需要设置为null temp.find(null,null,{skip:2},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }, //{ _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 } ] console.log(docs); }) findById() Model.findById(id, [projection], [options], [callback]) 　　显示第0个元素的所有字段 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findById(aIDArr[0],function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) }) 　　以上代码的另一种写法如下 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findById(aIDArr[0]).exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) }) 　　只输出name字段 temp.findById(aIDArr[0],{name:1,_id:0},function(err,doc){ //{ name: 'huochai'} console.log(doc); }) 　　或者写成下面这种形式 temp.findById(aIDArr[0],{name:1,_id:0}).exec(function(err,doc){ //{ name: 'huochai'} console.log(doc); }) 　　输出最少的字段 temp.findById(aIDArr[0],{lean:true},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c } console.log(doc); }) temp.findById(aIDArr[0],{lean:true}).exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c } console.log(doc); }) findOne() 　　该方法返回查找到的所有实例的第一个 Model.findOne([conditions], [projection], [options], [callback]) 　　找出age>20的文档中的第一个文档 temp.findOne({age:{$gt : 20}},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) temp.findOne({age:{$gt : 20}}).exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) 　　找出age>20的文档中的第一个文档，且只输出name字段 temp.findOne({age:{$gt : 20}},{name:1,_id:0},function(err,doc){ //{ name: 'huochai' } console.log(doc); }) temp.findOne({age:{$gt : 20}},{name:1,_id:0}).exec(function(err,doc){ //{ name: 'huochai' } console.log(doc); }) 　　找出age>20的文档中的第一个文档，且输出包含name字段在内的最短字段 temp.findOne({age:{$gt : 20}},\"name\",{lean:true},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai' } console.log(doc); }) temp.findOne({age:{$gt : 20}},\"name\").lean().exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai' } console.log(doc); }) 文档查询中，常用的查询条件如下 $gt　　　　大于 $gte　　　 大于等于 $lt　　　　小于 $lte　　　 小于等于 $ne　　　　不等于 this.ctx.model.Article.find({“sort”:{ $get:18 , $lte:30 }); $or　　　　或关系 $nor　　　 或关系取反 $in　　　　在多个值范围内 $nin　　　 不在多个值范围内 $all　　　 匹配数组中多个值 this.ctx.model.Article.find({\"title\":{ $in:[20,21,22.\"haha\"]} ); this.ctx.model.Article.find({\"$or\" : [ {\"age\":18} , {\"name\":\"wxw\"} ] }); $regex　　 正则，用于模糊查询 this.ctx.model.Article.find( {\"name\" : /joe/i } ); $size　　　匹配数组大小 this.ctx.model.Article.find({\"array\":{$size : 3} }); //查询数组长度为三的 $maxDistance　范围查询，距离（基于LBS） $mod　　　　取模运算 $near　　　 邻域查询，查询附近的位置（基于LBS） $exists　　 字段是否存在 this.ctx.model.Article.find({name: {$exists: true}},function(error,docs){ console.log(doc) //存在 }); this.ctx.model.Article.find({telephone: {$exists: false}},function(error,docs){ console.log(doc)//不存在 }); $elemMatch　匹配内数组内的元素 $within　　　范围查询（基于LBS） $box　　　　 范围查询，矩形范围（基于LBS） $center　　　范围醒询，圆形范围（基于LBS） $centerSphere　范围查询，球形范围（基于LBS） $slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素 this.ctx.model.Article.find({\"array\":{$slice : 10} }); // 获取匹配到数组的前10个元素 this.ctx.model.Article.find({\"array\":{$slice : [5,10]} }); // 获取匹配到数组的5-10个元素 $where 　　如果要进行更复杂的查询，需要使用$where操作符，$where操作符功能强大而且灵活，它可以使用任意的JavaScript作为查询的一部分，包含JavaScript表达式的字符串或者JavaScript函数 　　使用字符串: temp.find({$where:\"this.x == this.y\"},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }) temp.find({$where:\"obj.x == obj.y\"},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }) 　　使用函数 temp.find({$where:function(){ return obj.x !== obj.y; }},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 } ] console.log(docs); }) temp.find({$where:function(){ return this.x !== this.y; }},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 } ] console.log(docs); }) 链式查询 在查询时候，不带回调，而查询条件通过API函数来制定，例如： var query = PersonModel.findOne({'name.last':'dragon'}); query.select('some select'); query.exec(function(err,pserson){ //如果err==null，则person就能取到数据 }); 这种方式相对直接查询，分的比较明细，如果不带callback，则返回query，query没有执行的预编译查询语句，该query对象执行的方法都将返回自己，只有在执行exec方法时才执行查询，而且必须有回调。 因为query的操作始终返回自身，我们可以采用更形象的链式写法 Person .find({ occupation: /host/ }) .where('name.last').equals('Ghost') .where('age').gt(17).lt(66) .where('likes').in(['vaporizing', 'talking']) .limit(10) .sort('-occupation') .select('name occupation') .hint({age:1,name:1,like:-1}) //是否启用稀疏索引 也就是如果这内部的没有值则跳过该值 1 标识需要 2标识不需要 .exec(callback); "},"3 Mongoose/3.8 Mongoose的查询后处理.html":{"url":"3 Mongoose/3.8 Mongoose的查询后处理.html","title":"3.8 Mongoose的查询后处理","keywords":"","body":"Mongoose查询后处理 　　常用的查询后处理的方法如下所示 sort 排序 skip 跳过 limit 限制 select 显示字段 exect 执行 count 计数 distinct 去重 var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }) sort() 　　按age从小到大排序 temp.find().sort(\"age\").exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 } ] console.log(docs); }); 　　按x从小到大，age从大到小排列 temp.find().sort(\"x -age\").exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }); skip() 　　跳过1个，显示其他 temp.find().skip(1).exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }); limit() 　　显示2个 temp.find().limit(2).exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 } ] console.log(docs); }); select() 　　显示name、age字段，不显示_id字段 temp.find().select(\"name age -_id\").exec(function(err,docs){ //[ { name: 'huochai', age: 27 },{ name: 'wang', age: 18 },{ name: 'huo', age: 30 },{ name: 'li', age: 20 } ] console.log(docs); }); temp.find().select({name:1, age:1, _id:0}).exec(function(err,docs){ //[ { name: 'huochai', age: 27 },{ name: 'wang', age: 18 },{ name: 'huo', age: 30 },{ name: 'li', age: 20 } ] console.log(docs); }); 　　下面将以上方法结合起来使用，跳过第1个后，只显示2个数据，按照age由大到小排序，且不显示_id字段 temp.find().skip(1).limit(2).sort(\"-age\").select(\"-_id\").exec(function(err,docs){ //[ { name: 'huochai', age: 27, x: 1, y: 2 }, //{ name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }); count() 　　显示集合temps中的文档数量 temp.find().count(function(err,count){ console.log(count);//4 }); distinct() 　　返回集合temps中的x的值 temp.find().distinct('x',function(err,distinct){ console.log(distinct);//[ 1, 2 ] }); "},"3 Mongoose/3.9 Mongoose基于Model的新增和删除操作.html":{"url":"3 Mongoose/3.9 Mongoose基于Model的新增和删除操作.html","title":"3.9 Mongoose基于Model的新增和删除操作","keywords":"","body":"基于Model的文档新增和删除 文档新增 　　文档新增有三种方法，一种是使用上面介绍过的文档的save()方法，另一种是使用模型model的create()方法，最后一种是模型model的insertMany()方法 save() [注意]回调函数可以省略 save([options], [options.safe], [options.validateBeforeSave], [fn]) 　　新建{age:10,name:'save'}文档，并保存 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); //使用链式写法 new temp({age:10,name:'save'}).save(function(err,doc){ //[ { _id: 59720bc0d2b1125cbcd60b3f, age: 10, name: 'save', __v: 0 } ] console.log(doc); }); } }); create() 　　使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以==同时新增多个文档== Model.create(doc(s), [callback]) 　　新增{name:\"xiaowang\"}，{name:\"xiaoli\"}这两个文档 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.create({name:\"xiaowang\"},{name:\"xiaoli\"},function(err,doc1,doc2){ //{ __v: 0, name: 'xiaowang', _id: 59720d83ad8a953f5cd04664 } console.log(doc1); //{ __v: 0, name: 'xiaoli', _id: 59720d83ad8a953f5cd04665 } console.log(doc2); }); } }); insertMany() Model.insertMany(doc(s), [options], [callback]) 　　新增{name:\"a\"}，{name:\"b\"}这两个文档 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.insertMany([{name:\"a\"},{name:\"b\"}],function(err,docs){ //[ { __v: 0, name: 'a', _id: 59720ea1bbf5792af824b30c }, //{ __v: 0, name: 'b', _id: 59720ea1bbf5792af824b30d } ] console.log(docs); }); } }); 文档删除 　　有三种方法用于文档删除 remove() findOneAndRemove() findByIdAndRemove() remove() 　　remove有两种形式，一种是文档的remove()方法，一种是Model的remove()方法 　　下面介绍Model的remove()方法，该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}　　 model.remove(conditions, [callback]) 　　删除数据库中名称包括'30'的数据 temp.remove({name:/30/},function(err){}) 　　[注意]remove()方法中的回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码 temp.remove({name:/30/}).exec() 　　下面介绍文档的remove()方法，该方法的参数回调函数的形式如下function(err,doc){} document.remove([callback]) 　　删除数据库中名称包含'huo'的数据 [注意]文档的remove()方法的回调函数参数可以省略 temp.find({name:/huo/},function(err,doc){ doc.forEach(function(item,index,arr){ item.remove(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 30 } //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 60 } console.log(doc); }) }) }) findOneAndRemove() 　　model的remove()会删除符合条件的所有数据，如果只删除符合条件的第一条数据，则可以使用model的findOneAndRemove()方法 Model.findOneAndRemove(conditions, [options], [callback]) 　　集合temps现有数据如下 　　现在删除第一个年龄小于20的数据 temp.findOneAndRemove({age:{$lt:20}},function(err,doc){ //{ _id: 5972d3f3e6f98ec60e3dc873, name: 'wang', age: 18 } console.log(doc); }) 　　与model的remove()方法相同，回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码 temp.findOneAndRemove({age:{$lt:20}}).exec() findByIdAndRemove() Model.findByIdAndRemove(id, [options], [callback]) 　　删除第0个元素 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findByIdAndRemove(aIDArr[0],function(err,doc){ //{ _id: 5972d754e6f98ec60e3dc882, name: 'huochai', age: 27 } console.log(doc); }) }) 　　类似的，该方法也不能省略回调函数，否则数据不会被删除。当然，可以使用exec()方法来简写代码 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findByIdAndRemove(aIDArr[0]).exec() }) "},"Attachment/1.1 ImmutableJS.html":{"url":"Attachment/1.1 ImmutableJS.html","title":"1.1 ImmutableJS","keywords":"","body":""}}