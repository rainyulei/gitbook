{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 个人整理的学习资料和笔记 "},"1.koa/":{"url":"1.koa/","title":"1.koa","keywords":"","body":"Koa 学习路径 koa 基础使用 koa级联以及中间件顺序 koa-router koa-bodyparse koa-static 以及passport第三方登录 jwt鉴权 passport表单验证 "},"1.koa/1.1 DOC-Koa 以及中间件学习笔记.html":{"url":"1.koa/1.1 DOC-Koa 以及中间件学习笔记.html","title":"1.1 DOC-Koa 以及中间件学习笔记","keywords":"","body":"Koa 以及中间件学习笔记 简单开始 级联 next() 暂停当前函数的执行，进行下面函数的执行，然后会到上游next函数执行处，继续向下执行。 const Koa =require('koa') const app = new Koa() app.use(async (ctx, next) =>{ console.log(1) await next() const rt = ctx.response.get('X-Response-Time') console.log(`${ctx.method} ${ctx.url} - ${rt}`); console.log(2) }) app.use(async (ctx, next) =>{ console.log(3) const start =Date.now() await next() const ms= Date.now() - start ctx.set('X-Response-Time',`${ms}ms`) console.log(4); }) app.use(async ctx =>{ ctx.body='Hello world' console.log(5) }) app.listen(3000) // 1 3 5 4 2 属性 app的属性和方法 app.env 环境变量 默认使NODE_ENV development app.proxy //设置代理 app.subdomainOffset 可以监听多个端口 app.callback() 将方法用于 http.createServer https.createServer 或者connect 和express程序 app.use(function) 将给定的中间件方法添加到此应用程序 app.keys 设置Cookie 密匙 app.context 从外部直接向ctx 内部添加属性 app.context.db = db(); app.use(async ctx => { console.log(ctx.db); }); 错误处理 通过监听 error 事件进行事件处理 app.on('error', err , ctx=> { //ctx 可以继续向下传递 log.error('server error', err) //错误日志 }); ctx 属性 基本属性 ctx.req ctx.res node 的请求与相应对象 ctx.responce ctx.request koa 的对象 ctx.state 推荐的进行变量绑定的地方 ctx.app app对象 ctx.app.emit 触发on的绑定事件 ctx.cookies.set 设置cookie ctx.cookies.get 获取cookis ctx.throw([status], [msg], [properties]) 通常使用户的错误 而不是服务器的错误 http-errors ctx.assert(value, [status], [msg], [properties]) 用于断言 当第一个值为false的时候 第二值为错误码 第三个值使message http-assert Request 别名 以下访问器和 Request 别名等效： ctx.header 请求的标识头 可设置 ctx.headers ==上面 ctx.method 请求方法 可设置 ctx.url 请求的url 可设置 ctx.originalUrl 获取请求原始URL ctx.origin 获取URL的来源，包括 protocol 和 host。 ctx.href ctx.path ctx.path= ctx.query ctx.query= ctx.querystring ctx.querystring= ctx.host ctx.hostname http://localhost:3000 -------origin 常用 http://localhost:3000/apple?abc=11111 -------href /apple?abc=11111 -------originalUrl /apple -------path 常用 /apple?abc=11111 -------url { abc: '11111' } -------query 常用 abc=11111 -------querystring localhost:3000 -------host localhost -------hostname ctx.fresh 检查缓存是否新鲜 也就是内容没有改变。 在设置一个或多个这些响应头后应该引用它。 ctx.stale 以上面相反 ctx.socket request.socket 返回请求套接字。 ctx.protocol 返回请求协议，“https” 或 “http”。当 app.proxy 是 true 时支持 X-Forwarded-Proto。 ctx.secure 通过 ctx.protocol == \"https\" 来检查请求是否通过 TLS 发出。 ctx.ip 返回请求的IP ctx.ips 返回转发过后的多个IP ctx.subdomains 返回子域名 根据 subdomainsoffset偏移量试着 ctx.is() 检查传入请求是否包含 Content-Type 头字段， 并且包含任意的 mime type。 如果没有请求主体，返回 null。 如果没有内容类型，或者匹配失败，则返回 false。 反之则返回匹配的 content-type。 ctx.accepts() request.accepts(types) 通过类型检查 可以适用switch设置 ctx.acceptsEncodings() request.acceptsEncodings(encodings) encodings检查 ctx.acceptsCharsets() request.acceptsCharsets(charsets) 编码类型检查 ctx.acceptsLanguages() request.acceptsLanguages(langs) 语言类型检查 ctx.get() request.get(field) 返回请求标头。 Response 别名 以下访问器和 Response 别名等效： ctx.body ctx.body= string 写入 Buffer 写入 Stream 管道 Object || Array JSON-字符串化 null 无内容响应 ctx.status 状态码 ctx.status= ctx.message 信息 ctx.message= ctx.length= 长度 ctx.length ctx.type= 获取响应 Content-Type 不含参数 \"charset\"。 ctx.type ctx.headerSent 检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知。 ctx.redirect() response.redirect(url, [alt]) ctx.attachment()将 Content-Disposition 设置为 “附件” 以指示客户端提示下载。(可选)指定下载的 filename 和部分 参数。 ctx.set() 设置响应标头 field 到 value: 用一个对象设置多个响应标头fields: ctx.append() 用值 val 附加额外的标头 field。 ctx.remove() 移除表头 ctx.lastModified= 将 Last-Modified 标头返回为 Date, 如果存在。 检查最后的更改事件 ctx.etag= 设置etag 头部 response.is(types...) 。这对于创建操纵响应的中间件特别有用。 html-minifier，可以削减除流之外的所有HTML响应。 response.vary(field) 查看在 field 上变化。 response.flushHeaders() 刷新任何设置的标头，并开始主体。 缓存 使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control Cache-Control 响应头表示了资源是否可以被缓存，以及缓存的有效期。 no-cache 为本次响应不可直接用于后续请求（在没有向服务器进行校验的情况下） no-store 为禁止缓存（不得存储到非易失性介质，如果有的话尽量移除，用于敏感信息） private为仅 UA 可缓存 public为大家都可以缓存。 可以添加过期时间 max-age Etag 响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。 Etag 响应头字段表示资源的版本 浏览器在发送请求时会带 If-None-Match 头字段， Last-Modified 响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。 if-modified-since 在请求头中 时间戳 如果没有过过期时间则可以直接适用缓存 返回304 而不返回任何资源 否则返回一个Last-Modified', new Date().toString() 设置新时间 koa 中间件 Keygrip是一个node.js模块，用于通过轮换凭证系统对数据（如cookie或URL）进行签名和验证，其中可以添加新服务器密钥并定期删除旧服务器密钥，而不会使客户端凭据无效。 html-minifier 缩小html 大小 koa-router 路由 koa-bodyparser 解析post koa-session session 中间件 koa-logger koa 使用日志打印的中间件 koa-router 路由使用 /* * @Author: yu-lei * @Date: 2019-08-22 20:02:15 * @Last Modified by: yu-lei * @Last Modified time: 2019-08-22 23:06:14 */ /** * 包区域 */ const koa =require('koa') const koaRouter = require('koa-router') const koaBodyparser = require('koa-bodyparser') /** * 定义区域 */ const app =new koa() const router = new koaRouter() /** * 文件区域 */ //路由 const userRoutes = require('./routers/users')() const homeRoutes = require('./routers/homes')() /** * 中间件 */ app.use(koaBodyparser()) app.use(router.routes()) app.use(homeRoutes.routes()) app.use(userRoutes.routes()) app.use(router.allowedMethods()) //开启所有的请求方法 /** * 服务器 */ app.listen(3000, () =>{ console.log(\"服务器已经开启！\") }) 路由匹配方式 router.all('/*' , async (ctx,next) =>{ console.log(ctx.url) // 决绝特殊访问服务 // 搜索引擎优化 //roubat // 过滤服务 await next() }) router.get()// get|put|post|patch|delete|del|all router.regiest('path','GET',(ctx.next)=>{}) // 注册方法 路由的三种传递参数方式 1 通过动态router 传递 通过ctx.params.id 获取 router.get('/home/:id',async (ctx,next) =>{ ctx.body=\"home route\" console.log(ctx.params.id) // }) 2 通过query 字符串传递 通过ctx.query.参数名称获取 router.get('/home',async (ctx,next) =>{ ctx.body=\"home route\" console.log(ctx.query.id) // }) 3 通过post 传递 通过 koa-bodyparser 内的 ctx.request.body 获取 router.post('/home',async (ctx) =>{ console.log(ctx.request.body) ctx.body=ctx.request.body // console.log(ctx.request.body) }) redirect router.redirect('从那个路由'，’跳转到那个路由‘，状态码) // redirect 可能不需要匹配prefex 和父组件也会 匹配到路由跳转 use 嵌套路由 const userRouter = new koaRouter({ prefix:'/user' }) userRouter.get('/admin',async ctx=>{ //todo }) //中间件使用方法 router.use('/home',userRouter.routes(),userRouter.allowedMethods({配置})) //请求地址为 // /home/user/admin 显示嵌套的父级路由 然后是子集路由的prefix 然后是接口 router.param(param, middleware) 所有带有id 参数的路由全部需要先经过这个路由 const router = new koaRouter({ prefix:'/home' }) //子路由 router // 所有带有id 参数的路由全部需要先经过这个路由 .param('id',async (id, ctx, next) =>{ console.log(ctx.path,'param'); await next() }) .get('/user/:id' , async ctx =>{ console.log(1,ctx.params.id) }) .get('/haha/:id' , async ctx =>{ console.log(2,ctx.params.id) }) .redirect('/abc/:id','/haha/1',303) return router "},"2.mongoose/":{"url":"2.mongoose/","title":"2.mongoose","keywords":"","body":"mongoose 学习路径 mongoDB 基础使用 mongooDB 查询操作符 mongoDB 管道操作 mongoose 基础使用 mongoose 操作符和链式调用查询 mongoose 子文档查询以及更新操作 koa 集成mongoose嵌套多表操作 "},"2.mongoose/2.1 DOC-mongodb.html":{"url":"2.mongoose/2.1 DOC-mongodb.html","title":"2.1 DOC-mongodb","keywords":"","body":"mongDB mongoDB 一些特殊的地方 mongdb 中的主键 生成时间 自增长的数字和线程号 机器服务器号组合生成的 mongo 中操作条件就是在当前的数据解构中再加一层括号 mongo 中有几种层级 1 db 库 2 collection 表 3 document 文档级别 也就是一次时候输入操作在 insert 语句括号中的整个插入对象 mongodb 事物支持不友好 需要做两次操作的时候 要自己实现事物，mongodb 的插入原子性都是基于方法来实现的 mongodb 主键 为_id 默认的 在查询字段的时候建议使用$ in 而不是$or $elemMatch ， $slice ，以及 $ 是用来指定返回数组中包含映射元素的 唯一 方式。不能使用数组索引来指定映射的特定数组元素； 例如 db.users.find( { status: \"A\" }, { name: 1, status: 1, points: { $slice: -1 } } ) # 可以返回status 为A的 points数组中的的最后一个元素 db.users.find( {} , \"ratings.0\": 1 })#映射不会映射到数组的第一个元素，这样写不对。 db.users.find( { \"badges.0\": \"black\" } )#可以得到数组一个属性时black的 # 也就是说$elemMatch ， $slice ，以及 \\$ 操作的是数组内映射关系，数组内元素关系 而不用这个几个操作符操作的是数组名 mongoDB 增删改查 CRUD 操作 增 插入文档 mongo 中提供了三条命令来插入 ```javascript # 返回 WriteResult 对象 db.collection.insert() #version 3.2新增 插入一条 返回插入数据的 primary key _id objectID db.collection.insertOne() # version 3.2 新增同时插入多条数据 一条失败前面的成功后面的全部失败 db.collection.insertMany({document数组}， {writeConcern ： ， ordered ： 删除方法 ```javascript db.collection.remove() #删除符合条件的 可由 justone属性指定 删除一条 db.collection.deleteOne()#删除第一条符合条件的 3.2 db.collection.deleteMany() #删除多条条件选中 3.2 ``` 查询的方法 {}代表并且条件 ObjectId 是一个 12 字节 BSON 类型数据，有以下格式： - 前 4 个字节表示时间戳 - 接下来的 3 个字节是机器标识码 - 紧接的两个字节由进程 id 组成（PID） - 最后三个字节是随机数 $ 后面接条件符号 db.user.find({age:12}) # 表明查询年龄等于12岁的 db.user.find({age:{$gt:12}}) # 表明查询年龄大于12岁的 db.user.find({age:{$gt:12，$lt:30}}) # 表明查询年龄大于12岁并且小于30 的 db.user.find({age:{$or：[{$gt:12},{$lt:30}]}}) # 表明查询年龄大于12岁并且小于30 的 db.user.find({age:{$exists:true}}) # 查询年龄字段存在 数组的查询 用：方式表示数组的并行属于 db.user.find({数组;'数组内数据'}) 内嵌对象的查询，用点的方式 表示内嵌 db.user.find({对象.子对象;'要查询的内容'}) 数组内储存对象 #数组名：[{属性1：值},{},{}] db.user.find({\"数组名:属性1\"：值})可查出 $elemMatch 指定数组内多项条件同时过滤，数组内查询时的并且条件 指定内置数据的位置 db.user.find({ '数组名.下标.属性': '值' }) 正则 不推荐使用正则筛选一个大体量的数据 db.user.find({name:{\\$regex:\"正则\"}}) $size 查询大小 但是会把数组中含有对象和含有字符串的全部查询出来因此数据的一致性有挑战 find 的第二个参数 显示字段 db.user.find({条件}，{name:1,age:1}) # 1 显示 0 不显示此字段 ID 要不显示必须手动指定为0，此方法在显示数组内字段会有缺陷 # 这样查询出来的就会值显示其 ID name 和age 三个字段 其他的字段全部隐藏 # 这个可以显示内嵌在对象或者数组中的字段 查询空字段 如果在 mngodb 中查询某一个字段的值为空的时候需要指定{ name : { $type: 10 } }查询 仅仅 匹配那些包含值是 null 的 name 字段的文档,亦即 条目字段的值是 BSON 类型中的 Null (即 10 ): 存在检查 { name : { $exists: false } } 检查是否存在该属性 更改 update 的$set db.user.update({条件}，{name:1,age:1}) # 如果不写$set 会把user的匹配所有字段全部洗掉 变成后面的对象 # 而加入$set后会自动查找匹配的字段 进行替换 update 的 $unset 把字段删除 相当于删除某匹配字段 update 的第三个选项 {returnnewdocument：true} {motli:true} db.user.findOneAndupdate({条件}，{name:1,age:1},{new:true}) # {motli:true} 一起处理 多个一起 #returnnewdocument：true 返回更改过后的新文档 # upsert 有就更改 没有就插入 原子性的 # 批量操作 bulkWrite（）方法 在使用的时候由两种模式 1 有序插入 通过选项 ordered true 默认 2 无序插入 设置为 ordered false #bulkWrite（）支持以下写操作 # insertOne() # updateOne() # updateMany() # replaceOne() # deleteOne() # deleteMany() #使用方法 try { db.characters.bulkWrite( [ { insertOne : { \"document\" : { \"_id\" : 4, \"char\" : \"Dithras\", \"class\" : \"barbarian\", \"lvl\" : 4 } } }, { updateOne : { \"filter\" : { \"char\" : \"Eldon\" }, \"update\" : { $set : { \"status\" : \"Critical Injury\" } } } }, { deleteOne : { \"filter\" : { \"char\" : \"Brisbane\"} } }, { replaceOne : { \"filter\" : { \"char\" : \"Meldane\" }, \"replacement\" : { \"char\" : \"Tanys\", \"class\" : \"oracle\", \"lvl\" : 4 } } } ] ); } catch (e) { print(e); } 数据结构 浮点数的经度丢失需要使用 decimal 格式来处理 ，包括 java 和 c 和 javascript 都在使用而 mongoode 默认就会使用这个格式 ， mongo 可以直接存 js 代码指定其类型 mongo 排序 聚合 aggregate 聚合操作 对表中的文档进行相应的处理 $match 相当于mysql的have $group 相当于 groupby $unwide 拆分数组 db.suer.aggregate() 索引 创建索引 db.user.createIndex({字段名：1}，{unique:1}) 索引 是不是唯一索引 删除索引 db.user.dropindex() 有索引之后根据索引查询速度会特别快 ，但是插入会很慢，使用空间来换时间，不会读取文档而是读取索引 "},"2.mongoose/2.2 DOC-mongodb的服务器配置管理.html":{"url":"2.mongoose/2.2 DOC-mongodb的服务器配置管理.html","title":"2.2 DOC-mongodb的服务器配置管理","keywords":"","body":"CentOS 部署 MongoDB 安装过程 1、添加 MongoDB 的源： mongodb-org 这个包默认不存在 CentOS 的源里，所以要先添加到我们服务器中： vi /etc/yum.repos.d/mongodb-org.repo 然后访问 Install on Red Hat 找到最新的 MongoDB 稳定版本并添加到上面打开的文档中，类似这样： [mongodb-org-4.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc [mongodb-org-3.6] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc [mongodb-org-3.4] name=MongoDB 3.4 Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/ gpgcheck=0 enabled=1 编辑并保存文件，查看服务器源列表中是否已添加成功（留意 mongodb-org-版本）： $ yum repolist # 输出一般如下 . . . repo id repo name base/7/x86_64 CentOS-7 - Base extras/7/x86_64 CentOS-7 - Extras mongodb-org-3.2/7/x86_64 MongoDB Repository updates/7/x86_64 CentOS-7 - Updates . . . 2、安装 MongoDB： yum install mongodb-org 3、启动 MongoDB： $ sudo systemctl start mongod 如有需要重新解析改动后的 /etc/mongod.conf 配置文件，可以执行： $ sudo systemctl reload mongod 4、因为 systemctl 并不返回启动结果，所以可以通过以下命令查看是否启动： $ sudo tail /var/log/mongodb/mongod.log 查找是否包含该日志，若出现则表示服务已启动，可以通过 mongo 来开启命令： . . . [initandlisten] waiting for connections on port 27017 5、开机自启动 首先查看是否已启用： $ systemctl is-enabled mongod; echo $? # 查看输出是否包含 enabled 字样 . . . enabled 0 若无，可以手动启动： $ sudo systemctl enable mongod 6、导入 example 数据 mongorestore -h 127.0.0.1:27017 -d doracms2 --drop #centos上要引入的数据的目录 7 创建管理员 和操作员 mongo ... ... use admin # 创建管理员 db.createUser({user: \"admin\",pwd: \"admin\",roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]}) 退出 然后使用管理员账号重新登录 创建操作员 # 创建数据操作员 db.createUser({user: \"leiyuyang\",pwd: \"leiyuyang\",roles: [ { role: \"readWrite\", db: \"doracms2\" } ]}) 8 修改配置文件 mongdb.conf 添加在 security: auth：true 如果是在3.x 版本以上添加 security: authorization: \"enabled\" 查看数据： $ mongo $ db.restaurants.find().limit(1).pretty() # 输出 { \"_id\" : ObjectId(\"57e0443b46af7966d1c8fa68\"), \"address\" : { \"building\" : \"1007\", \"coord\" : [ -73.856077, 40.848447 ], \"street\" : \"Morris Park Ave\", \"zipcode\" : \"10462\" }, \"borough\" : \"Bronx\", \"cuisine\" : \"Bakery\", \"grades\" : [ { \"date\" : ISODate(\"2014-03-03T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 2 }, { \"date\" : ISODate(\"2013-09-11T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 6 }, { \"date\" : ISODate(\"2013-01-24T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 10 }, { \"date\" : ISODate(\"2011-11-23T00:00:00Z\"), \"grade\" : \"A\", \"score\" : 9 }, { \"date\" : ISODate(\"2011-03-10T00:00:00Z\"), \"grade\" : \"B\", \"score\" : 14 } ], \"name\" : \"Morris Park Bake Shop\", \"restaurant_id\" : \"30075445\" } 删除数据库： $ db.restaurants.drop() 数据库操作 1、添加数据库用户 $ mongo --port 27017 $ use admin $ db.createUser( { user: \"root\", pwd: \"xxxxxx\", roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ] }) # 现在我们为 MongoDB 的 admin 数据库添加一个用户 root，MongoDB 可以为每个数据库 # 都建立权限认证，也就是你可以指定某个用户可以登录到哪个数据库。上面的代码，我们为 # admin 数据库添加了一个 root 用户，在 MongoDB 中 admin 数据库是一个特别的数据库， # 这个数据库的用户，可以访问 Mongodb 中的所有数据库。 2、用户登录 # 方式一 $ mongo --port 27017 -u \"root\" -p \"xxxxxx\" --authenticationDatabase \"admin\" # 方式二 $ mongo --port 27017 $ use admin $ db.auth(\"root\", \"xxxxxx\") // 输出 1 表示验证成功，并且不会报错了 3、账户相关操作： # 查询某个数据库下用户（每个数据库的用户账号都是以文档形式存储在 system.users 集合里面的） $ db.system.users.find() # 删除某个数据库下的所有用户 $ db.system.users.remove() # 删除指定用户 $ db.system.users.remove({'user':'用户名'}) # 修改账户密码 db.changeUserPassword(\"username\", \"newpassword\") 4、数据库操作 $ mongo --port 27017 $ use admin $ db.auth(\"root\", \"xxxxxx\") $ show dbs # 查看数据库 $ use # 选择数据库 $ show collections # 查看 collections $ db.collectionName.find() # 查看 documents $ use # 创建数据库 $ db.test.insert({\"name\":\"tutorials point\"}) # 随便插入点数据（才能出现） 5、数据的导入与导出 # mongoexport导出表，或者表中部分字段（一般可以简写） $ mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --csv -q 条件 -f 字段 -o newdbexport.json/dat/csv -h：数据库宿主机的IP -u：数据库用户名 -p：数据库密码 -d：数据库名字 -c：集合的名字 -f：导出的列名 -q：导出数据的过滤条件 -o：导出文件的目录及文件名（/xx/xx/xx.json） --type：json 或 csv（默认是 json） 比如导出整张表： $ mongoexport -d test -c users -o allusers.dat 比如导出部分字段： $ mongoexport -d test -c users --csv -f uid,name,sex -o test/users.csv 比如根据条件敢出数据： $ mongoexport -d test -c users -q '{uid:{$gt:1}}' -o test/users.json # mongoimport 导入表，或者表中部分字段 $ mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 比如还原导出的表数据（--upsert 插入或者更新现有数据） $ mongoimport -d test -c users --upsert test/users.dat 比如部分字段的表数据导入（--upsertFields根--upsert一样） $ mongoimport -d test -c users --upsertFields uid,name,sex test/users.dat 比如还原csv文件 $ mongoimport -d test -c users --type csv --headerline --file test/users.csv # mongodump 备份数据库（如果想导出所有数据库，可以去掉-d） $ mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径 比如： $ mongodump -h 127.0.0.1 -p 30216 -d test -uxxxx -pxxxxx -o home/mongodb/ # mongorestore 还原数据库 $ mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径 比如： $ mongorestore -d test /home/mongodb/test 原 yum 升级 mongodb 2016年10月24日 14:12:29 huaism 阅读数：1782 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/huaishuming/article/details/52911159 名为升级实际是卸载重装。 主要流程 1. 备份 2. 卸载 3.安装 4.配置 5.还原 1.备份 不做解释 ./mongodump --host 127.0.0.1 --port 27017 --username root --password xxxx --out /application/mongodb_backup \\2. 卸载yum卸载mongodb及后续问题的解决 卸载过程 ``// 找出mongodb相关的安装包yum list installed | grep mongo// 删除指定的安装包,包名由上面的list命令获得yum erase mongodb.x86_64yum erase mongodb-server.x86_64 详细如下图： 确认删除了，查看which命令发现mongo指向了3.2.9高版本的程序了（之前已经有将高版本mongo路径添加到系统的环境变量）。 但下一步直接使用mongo却发现出错了 ``# mongo-bash: /usr/bin/mongo: No such file or directory 好吧，yum只删除了安装包，但没有把快捷方式一并清除。 那就把快捷方式指向高版本的mongodb的可执行文件吧。 ``ln -s /root/soft/mongodb/bin/mongo /usr/bin/mongo 好了，解决了。 如果没有设置软连接，则出现这个情况可能是，没启动服务 3.安装： 参考： 选中自己的版本进行安装 https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/ Configure the package management system (yum). Create a /etc/yum.repos.d/mongodb-org-3.2.repo file so that you can install MongoDB directly, using yum. Changed in version 3.0: MongoDB Linux packages are in a new repository beginning with 3.0. For the latest stable release of MongoDB Use the following repository file: $releasever 是系统版本 [mongodb-org-3.2] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc //执行安装 sudo yum install -y mongodb-org-3.2.10 mongodb-org-server-3.2.10 mongodb-org-shell-3.2.10 mongodb-org-mongos-3.2.10 mongodb-org-tools-3.2.10 //启动服务 service mongod start 4.还原： mongorestore /application/data_backup/mongodb \\5. 配置； 安装后 输入 mongo 会出现警告： \\1. 数量限制 解决办法 修改配置文件 /etc/security/limits.conf，添加配置信息： [root@localhost ~]# vi /etc/security/limits.conf ? `mongod soft nofile 64000``mongod hard nofile 64000``mongod soft nproc 32000``mongod hard nproc 32000` 重启 mongod 服务： 转载： 系统环境 Distributor ID: CentOS Description: CentOS release 6.7 (Final) Release: 6.7 Codename: Final 问题描述 在系统上安装mongodb之后报错。 (安装教程地址: https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/) 错误信息: WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’.We suggest setting it to ‘never’ WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’.We suggest setting it to ‘never’ WARNING: soft rlimits too low. rlimits set to 1024 processes, 65535 files. Number of processes should be at least 32767.5 : 0.5 times number of files. 如图： 解决方案 前两个warning sudo echo \"never\" > /sys/kernel/mm/transparent_hugepage/enabled sudo echo \"never\" > /sys/kernel/mm/transparent_hugepage/defrag 第三个warning vim /etc/security/limits.conf 添加一下几行 mongod soft nofile 64000 mongod hard nofile 64000 mongod soft nproc 32000 mongod hard nproc 32000 重启mongod sudo service mongod restart 成功 重启成功之后，所有报错都没啦，如下 ➜ ~ git:(master) mongo MongoDB shell version: 3.2.6 connecting to: test > "},"2.mongoose/2.3 Notes-mongooDB.html":{"url":"2.mongoose/2.3 Notes-mongooDB.html","title":"2.3 Notes-mongooDB","keywords":"","body":"mongooDB 数据库操作 创建数据库 和创建表 use 数据库名称 # 使用数据库 # 插入一条数据的同时就会创建表 db.表名.insert() # 删除 表 db.表名.drop() # 查询 db.表名.find(查询条件，查询的返回字段，输出的条件) # 查询又 skip 跳过 sort 排序 （1）正序 （-1）倒叙 limit （） 限制输出数量 $gt 等条件限制符号 # 条件是并且用{a，b} 或{$or:[条件a，条件b] # count 统计数量 # $set 更新 不加就是覆盖更改 remove(条件，{justone：true}) # 是删除 如果只删除一个 就使用justOne 索引 # 删除索引 db.user.dropIndex({\"字段名\"：1}) explain(\"executionStats\") # 语句执行时间 1 标识升序索引 -1 标识降序索引 # 设置索引 db.user.ensureIndex({\"字段名称\"：1}) # 查询索引 db.user.getIndeses() # 查询所有索引 # 设置复合索引 db.user.ensureIndex({\"字段名称\"：1，\"字段名称2\"：-1，}) # 唯一索引 db.user.ensureIndex({\"字段名称\"：1，\"字段名称2\"：-1，}，{unique:true}) # 字段不可以以重复 账户权限配置 管理员用户都在admin 中 use admin # 创建用户 db.createUser({ user:\"admin\", pwd:'123456', roles:[{role:'root',db:'admin'}] }) 扎到修改mongoodb数据库配置文件 路径 bin目录下的mongod.cfg 聚合管道 可以对集合中的文档数据进行变换和组合 // 通过 db.orders.aggregate([ {$match:{username:\"zhangsan\"}}, {$group:{age:30，total：{$sum:'$amount'}}} ]) 上面的代码是先查到 username 是张三的人，然后对所有的张三进行分组 30岁的一组 不是三十的一组，这个操作会返回连个组合 常见的操作符 $project 添加 删除 命名 需要显示的列 $lookup 引入其他集合数据 关联查询 $match 条件匹配 满足条件筛选进入下一组管道 $group 条件组合结果 统计 $sort 条件排序 $skip 跳过 $limit 限制数量 "},"2.mongoose/2.4 DOC-mongoose的全文.html":{"url":"2.mongoose/2.4 DOC-mongoose的全文.html","title":"2.4 DOC-mongoose的全文","keywords":"","body":"Mongoose基础入门 前面的话 　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具。本文将详细介绍如何使用Mongoose来操作MongoDB NodeJS驱动 　　在介绍Mongoose之前，首先介绍使用NodeJS操作MongoDB的方法 　　如果使用程序操作数据库，就要使用MongoDB驱动。MongoDB驱动实际上就是为应用程序提供的一个接口，不同的语言对应不同的驱动，NodeJS驱动不能应用在其他后端语言中 　　首先，安装mongodb npm install mongodb 　　接着，使用require()方法引入mongodb数据库；然后使用MongoClient对象的connect()方法连接mongodb；最后通过node来对mongodb进行异步的增删改查 　　在mongodb数据库中建立db1数据库，然后通过以下代码，建立col集合，并插入{\"a\":1}文档 var mongodb = require('mongodb'); mongodb.MongoClient.connect(\"mongodb://localhost/db1\",function(err,db){ if(!err){ db.collection(\"col\").insert({\"a\":1},function(err,result){ if(!err){ console.log(result); } }) } }) 　　最后返回结果如下 { result: { ok: 1, n: 1 }, ops: [ { a: 1, _id: 597077dc271d092728caa362 } ], insertedCount: 1, insertedIds: [ 597077dc271d092728caa362 ] } 概述 　　Mongoose是NodeJS的驱动，不能作为其他语言的驱动。Mongoose有两个特点 　　1、通过关系型数据库的思想来设计非关系型数据库 　　2、基于mongodb驱动，简化操作 　　Mongooose中，有三个比较重要的概念，分别是Schema、Model、Entity。它们的关系是：Schema生成Model，Model创造Document，Model和Document都可对数据库操作造成影响，但Model比Document更具操作性 Schema用于定义数据库的结构。类似创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection，Schema不具备操作数据库的能力 　　Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删查改。Model的每一个实例（instance）就是一个文档document 　　Document是由Model创建的实体，它的操作也会影响数据库 安装 　　安装nodejs和mongodb之后 ，使用npm来安装mongoose npm install mongoose 　　安装成功后，就可以通过 require('mongoose') 来使用 连接数据库 　　使用require()方法在项目中包含mongoose后，接下来使用connect()方法连接到MongoDB数据库 connect() mongoose.connect(url); 　　connect()最简单的使用方式，就是只要传入url参数即可，如下所示。连接到本地localhost的db1服务器 mongoose.connect('mongodb://localhost/db1'); 　　#### 传递用户名、密码 mongoose.connect('mongodb://username:password@host:port/database?options...'); options 　　connect()方法还接受一个选项对象options，该对象将传递给底层驱动程序。这里所包含的所有选项优先于连接字符串中传递的选项 mongoose.connect(uri, options); 　　可用选项如下所示 db -数据库设置 server -服务器设置 replset -副本集设置 user -用户名 pass -密码 auth -鉴权选项 mongos -连接多个数据库 promiseLibrary var options = { db: { native_parser: true }, server: { poolSize: 5 }, replset: { rs_name: 'myReplicaSetName' }, user: 'myUserName', pass: 'myPassword' } mongoose.connect(uri, options); 连接多个数据库 　　如果要连接多个数据库，只需要设置多个url以,隔开，同时设置mongos为true mongoose.connect('urlA,urlB,...', { mongos : true }) 回调 　　connect()函数还接受一个回调参数 mongoose.connect(uri, options, function(error) { }); 　　执行下列代码后，控制台输出“连接成功” var mongoose = require('mongoose'); mongoose.connect(\"mongodb://localhost/test\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); } }); 　　如果开启鉴权控制，以用户名\"u1\"，密码\"123456\"登录'db1'数据库。执行代码后，控制台输出“连接成功” var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); } }); disconnect() mongoose.disconnect() 　　 使用disconnect()方法可以断开连接 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); } }); setTimeout(function(){ mongoose.disconnect(function(){ console.log(\"断开连接\"); }) }, 2000); Schema 　　Schema主要用于定义MongoDB中集合Collection里文档document的结构　　 　　定义Schema非常简单，指定字段名和类型即可，支持的类型包括以下8种 String 字符串 Number 数字 Date 日期 Buffer 二进制 Boolean 布尔值 Mixed 混合类型 ObjectId 对象ID Array 数组 　　通过mongoose.Schema来调用Schema，然后使用new方法来创建schema对象 var mongoose = require('mongoose'); var Schema = mongoose.Schema; var mySchema = new Schema({ title: String, author: String, body: String, comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number } }); 　 > [注意]创建Schema对象时，声明字段类型有两种方法，一种是首字母大写的字段类型，另一种是引号包含的小写字段类型 var mySchema = new Schema({title:String, author:String}); //或者 var mySchema = new Schema({title:'string', author:'string'}); 　　如果需要在Schema定义后添加其他字段，可以使用add()方法 var MySchema = new Schema; MySchema.add({ name: 'string', color: 'string', price: 'number' }); timestamps 　　在schema中设置timestamps为true，schema映射的文档document会自动添加createdAt和updatedAt这两个字段，代表创建时间和更新时间 var UserSchema = new Schema( {...}, { timestamps: true } ); _id 　　每一个文档document都会被mongoose添加一个不重复的_id，_id的数据类型不是字符串，而是ObjectID类型。如果在查询语句中要使用_id，则需要使用findById语句，而不能使用find或findOne语句 　　 Model 　　模型Model是根据Schema编译出的构造器，或者称为类，通过Model可以实例化出文档对象document 　　文档document的创建和检索都需要通过模型Model来处理 model() mongoose.model() 　　使用model()方法，将Schema编译为Model.model()方法的第一个参数是模型名称 　[注意]一定要将model()方法的第一个参数和其返回值设置为相同的值，否则会出现不可预知的结果 　 　　Mongoose会将集合名称设置为模型名称的小写版。如果名称的最后一个字符是字母，则会变成复数；如果名称的最后一个字符是数字，则不变；如果模型名称为\"MyModel\"，则集合名称为\"mymodels\"；如果模型名称为\"Model1\"，则集合名称为\"model1\" var schema = new mongoose.Schema({ num:Number, name: String, size: String}); var MyModel = mongoose.model('MyModel', schema); 实例化文档document 　　通过对原型Model1使用new方法，实例化出文档document对象 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(err){ console.log('连接失败'); }else{ console.log('连接成功'); var schema = new mongoose.Schema({ num:Number, name: String, size: String}); var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ size: 'small' }); console.log(doc1.size);//'small' } }); 文档保存 　　通过new Model1()创建的文档doc1，必须通过save()方法，才能将创建的文档保存到数据库的集合中，集合名称为模型名称的小写复数版 　　回调函数是可选项，第一个参数为err，第二个参数为保存的文档对象 save(function (err, doc) {}) var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ num:Number, name: String, size: String }); var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ size: 'small' }); doc1.save(function (err,doc) { //{ __v: 0, size: 'small', _id: 5970daba61162662b45a24a1 } console.log(doc); }) } }); 　　由下图所示，db1数据库中的集合名称为mymodels，里面有一个{size:\"small\"}的文档 自定义方法 实例方法 　　Model的实例是document，内置实例方法有很多，如 save，可以通过Schema对象的methods属性给实例自定义扩展方法 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ num:Number, name: String, size: String }); schema.methods.findSimilarSizes = function(cb){ return this.model('MyModel').find({size:this.size},cb); } var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ name:'doc1', size: 'small' }); var doc2 = new MyModel({ name:'doc2', size: 'small' }); var doc3 = new MyModel({ name:'doc3', size: 'big' }); doc1.save(); doc2.save(); doc3.save(); setTimeout(function(){ doc1.findSimilarSizes(function(err,docs){ docs.forEach(function(item,index,arr){ //doc1 //doc2 console.log(item.name) }) }) },0) } }); 静态方法 　　通过Schema对象的statics属性给 Model 添加静态方法 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ num:Number, name: String, size: String }); schema.statics.findByName = function(name,cb){ return this.find({name: new RegExp(name,'i')},cb); } var MyModel = mongoose.model('MyModel', schema); var doc1 = new MyModel({ name:'doc1', size: 'small' }); var doc2 = new MyModel({ name:'doc2', size: 'small' }); var doc3 = new MyModel({ name:'doc3', size: 'big' }); doc1.save(); doc2.save(); doc3.save(); setTimeout(function(){ MyModel.findByName('doc1',function(err,docs){ //[ { _id: 5971e68f4f4216605880dca2,name: 'doc1',size: 'small',__v: 0 } ] console.log(docs); }) },0) } }); 　　由上所示，实例方法和静态方法的区别在于，静态方法是通过Schema对象的statics属性给model添加方法，实例方法是通过Schema对象的methods是给document添加方法 查询方法 　　通过schema对象的query属性，给model添加查询方法 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); schema.query.byName = function(name){ return this.find({name: new RegExp(name)}); } var temp = mongoose.model('temp', schema); temp.find().byName('huo').exec(function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, // { _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 } ] console.log(docs); }) } }); 文档新增 　　文档新增有三种方法，一种是使用上面介绍过的文档的save()方法，另一种是使用模型model的create()方法，最后一种是模型model的insertMany()方法 save() 　　> [注意]回调函数可以省略 save([options], [options.safe], [options.validateBeforeSave], [fn]) 　　新建{age:10,name:'save'}文档，并保存 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); //使用链式写法 new temp({age:10,name:'save'}).save(function(err,doc){ //[ { _id: 59720bc0d2b1125cbcd60b3f, age: 10, name: 'save', __v: 0 } ] console.log(doc); }); } }); create() 　　使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以==同时新增多个文档== Model.create(doc(s), [callback]) 　　新增{name:\"xiaowang\"}，{name:\"xiaoli\"}这两个文档 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.create({name:\"xiaowang\"},{name:\"xiaoli\"},function(err,doc1,doc2){ //{ __v: 0, name: 'xiaowang', _id: 59720d83ad8a953f5cd04664 } console.log(doc1); //{ __v: 0, name: 'xiaoli', _id: 59720d83ad8a953f5cd04665 } console.log(doc2); }); } }); insertMany() Model.insertMany(doc(s), [options], [callback]) 　　新增{name:\"a\"}，{name:\"b\"}这两个文档 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.insertMany([{name:\"a\"},{name:\"b\"}],function(err,docs){ //[ { __v: 0, name: 'a', _id: 59720ea1bbf5792af824b30c }, //{ __v: 0, name: 'b', _id: 59720ea1bbf5792af824b30d } ] console.log(docs); }); } }); 　 文档查询 　　使用Mongoose来查找文档很容易，有以下3种方法可供选择 find() findById() findOne() find() 　　第一个参数表示查询条件，第二个参数用于控制返回的字段 selection，第三个参数用于配置查询参数，第四个参数是回调函数，回调函数的形式为function(err,docs){} Model.find(conditions, [projection], [options], [callback]) 　　在数据库db1的集合temps中存在如下数据 　　现在，使用find()方法找出所有数据 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, //{ _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 18 }, //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }, //{ _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 } ] console.log(docs); }) } }); 　　找出年龄大于18的数据 temp.find({age:{$gte:18}},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, //{ _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 18 }, //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }] console.log(docs); }) 　　找出年龄大于18且名字里存在'huo'的数据 temp.find({name:/huo/,age:{$gte:18}},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 }, //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }] console.log(docs); }) 　　找出名字里存在'a'的数据，且只输出'name'字段 　　[注意]_id字段默认输出 temp.find({name:/a/},'name',function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86c, name: 'huochai' }, //{ _id: 5971f93be6f98ec60e3dc86d, name: 'wang' } ] console.log(docs); }) 　　如果确实不需要_id字段输出，可以进行如下设置 temp.find({name:/a/},{name:1,_id:0},function(err,docs){ //[ { name: 'huochai' }, { name: 'wang' } ] console.log(docs); }) 　　找出跳过前两条数据的其他所有数据 　　> [注意]如果使用第三个参数，前两个参数如果没有值，需要设置为null temp.find(null,null,{skip:2},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 30 }, //{ _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 } ] console.log(docs); }) findById() Model.findById(id, [projection], [options], [callback]) 　　显示第0个元素的所有字段 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findById(aIDArr[0],function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) }) 　　以上代码的另一种写法如下 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findById(aIDArr[0]).exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) }) 　　只输出name字段 temp.findById(aIDArr[0],{name:1,_id:0},function(err,doc){ //{ name: 'huochai'} console.log(doc); }) 　　或者写成下面这种形式 temp.findById(aIDArr[0],{name:1,_id:0}).exec(function(err,doc){ //{ name: 'huochai'} console.log(doc); }) 　　输出最少的字段 temp.findById(aIDArr[0],{lean:true},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c } console.log(doc); }) temp.findById(aIDArr[0],{lean:true}).exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c } console.log(doc); }) findOne() 　　该方法返回查找到的所有实例的第一个 Model.findOne([conditions], [projection], [options], [callback]) 　　找出age>20的文档中的第一个文档 temp.findOne({age:{$gt : 20}},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) temp.findOne({age:{$gt : 20}}).exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 } console.log(doc); }) 　　找出age>20的文档中的第一个文档，且只输出name字段 temp.findOne({age:{$gt : 20}},{name:1,_id:0},function(err,doc){ //{ name: 'huochai' } console.log(doc); }) temp.findOne({age:{$gt : 20}},{name:1,_id:0}).exec(function(err,doc){ //{ name: 'huochai' } console.log(doc); }) 　　找出age>20的文档中的第一个文档，且输出包含name字段在内的最短字段 temp.findOne({age:{$gt : 20}},\"name\",{lean:true},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai' } console.log(doc); }) temp.findOne({age:{$gt : 20}},\"name\").lean().exec(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai' } console.log(doc); }) 　文档查询中，常用的查询条件如下 $or　　　　或关系 $nor　　　 或关系取反 $gt　　　　大于 $gte　　　 大于等于 $lt　　　　小于 $lte　　　 小于等于 $ne　　　　不等于 $in　　　　在多个值范围内 $nin　　　 不在多个值范围内 $all　　　 匹配数组中多个值 $regex　　 正则，用于模糊查询 $size　　　匹配数组大小 $maxDistance　范围查询，距离（基于LBS） $mod　　　　取模运算 $near　　　 邻域查询，查询附近的位置（基于LBS） $exists　　 字段是否存在 $elemMatch　匹配内数组内的元素 $within　　　范围查询（基于LBS） $box　　　　 范围查询，矩形范围（基于LBS） $center　　　范围醒询，圆形范围（基于LBS） $centerSphere　范围查询，球形范围（基于LBS） $slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素 $where 　　如果要进行更复杂的查询，需要使用$where操作符，$where操作符功能强大而且灵活，它可以使用任意的JavaScript作为查询的一部分，包含JavaScript表达式的字符串或者JavaScript函数 　　使用字符串 temp.find({$where:\"this.x == this.y\"},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }) temp.find({$where:\"obj.x == obj.y\"},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }) 　　使用函数 temp.find({$where:function(){ return obj.x !== obj.y; }},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 } ] console.log(docs); }) temp.find({$where:function(){ return this.x !== this.y; }},function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 } ] console.log(docs); }) 文档更新 　　文档更新可以使用以下几种方法 update()//往上改 updateMany() //改多个 updateOne() //改一个 findByIdAndUpdate() //通过i的查询 然后改 fingOneAndUpdate() //找到一个就改 find() + save()//栈 让然后改 findOne() + save()//找一个改 update() 　　第一个参数conditions为查询条件，第二个参数doc为需要修改的数据，第三个参数options为控制选项，第四个参数是回调函数 Model.update(conditions, doc, [options], [callback]) 　options有如下选项 safe (boolean)： 默认为true。安全模式。 　　upsert (boolean)： 默认为false。如果不存在则创建新记录。 　　multi (boolean)： 默认为false。是否更新多个查询记录。 　　runValidators： 如果值为true，执行Validation验证。 　　setDefaultsOnInsert： 如果upsert选项为true，在新建时插入文档定义的默认值。 　　strict (boolean)： 以strict模式进行更新。 　　overwrite (boolean)： 默认为false。禁用update-only模式，允许覆盖记录。 　　数据库temps中现有数据如下 　　现在使用update()方法查询age大于20的数据，并将其年龄更改为40岁 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.update({age:{$gte:20}},{age:40},function(err,raw){ //{ n: 1, nModified: 1, ok: 1 } console.log(raw); }) } }); 　　经过以上操作，数据库结果如下。只有第一个数据更改为40岁。而第三个数据没有发生变化 　　如果要同时更新多个记录，需要设置options里的multi为true。下面将名字中有'a'字符的年龄设置为10岁 var mongoose = require('mongoose'); mongoose.connect(\"mongodb://u1:123456@localhost/db1\", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); temp.update({name:/a/},{age: 10},{multi:true},function(err,raw){ //{ n: 2, nModified: 2, ok: 1 } console.log(raw); }) } }); 　　如果设置的查找条件，数据库里的数据并不满足，默认什么事都不发生 temp.update({age:100},{name: \"hundred\"},function(err,raw){ //{ n: 0, nModified: 0, ok: 1 } console.log(raw); }) 　　如果设置options里的upsert参数为true，若没有符合查询条件的文档，mongo将会综合第一第二个参数向集合插入一个新的文档 temp.update({age:100},{name: \"hundred\"},{upsert:true},function(err,raw){ //{ n: 1, nModified: 0,upserted: [ { index: 0, _id: 5972c202d46b621fca7fc8c7 } ], ok: 1 } console.log(raw); }) temp.update({name:/aa/},{age: 0},{upsert:true},function(err,raw){ //{ n: 1, nModified: 0,upserted: [ { index: 0, _id: 5972c288d46b621fca7fdd8f } ], ok: 1 } console.log(raw); }) 　>　[注意]update()方法中的回调函数不能省略，否则数据不会被更新。如果回调函数里并没有什么有用的信息，则可以使用exec()简化代码 temp.update({name:/aa/},{age: 0},{upsert:true}).exec(); 更新子文档的方法 #这里的第一个要找到子文档的位置 具体到哪一条数据的哪一个子文档 temp.update({\"userid\":userid,\"cartList.productId\":productId}, #这里要更新的属性是 子文档 然后 .$.要更改的属性 ： 值 {cartList.$.productNum:10},[opintion],function(err,doc){ if(err){ res.json({ status: result: msg: }) return } doc...#TODO }) updateMany() 　　updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi:false}也无法只更新第一个文档 Model.updateMany(conditions, doc, [options], [callback]) 　　将数据库中名字中带有'huo'的数据，年龄变为50岁 temp.updateMany({name:/huo/},{age:50},function(err,raw){ //{ n: 2, nModified: 2, ok: 1 } console.log(raw); }); find() + save() 　　如果需要更新的操作比较复杂，可以使用find()+save()方法来处理，比如找到年龄小于30岁的数据，名字后面添加'30'字符 temp.find({age:{$lt:20}},function(err,docs){ //[ { _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 10 }, //{ _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 }] console.log(docs); docs.forEach(function(item,index,arr){ item.name += '30'; item.save(); }) //[ { _id: 5971f93be6f98ec60e3dc86d, name: 'wang30', age: 10 }, // { _id: 5971f93be6f98ec60e3dc86f, name: 'li30', age: 12 }] console.log(docs); }); updateOne() 　　updateOne()方法只能更新找到的第一条数据，即使设置{multi:true}也无法同时更新多个文档 　　将数据库中名字中带有'huo'的数据，年龄变为60岁 temp.updateOne({name:/huo/},{age:60},function(err,raw){ //{ n: 1, nModified: 1, ok: 1 } console.log(raw); }); findOne() + save() 　　如果需要更新的操作比较复杂，可以使用findOne()+save()方法来处理，比如找到名字为'huochai'的数据，年龄加100岁 temp.findOne({name:'huochai'},function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 10 } console.log(doc); doc.age += 100; doc.save(); //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 110 } console.log(doc); }); findOneAndUpdate() 　　fineOneAndUpdate()方法的第四个参数回调函数的形式如下function(err,doc){} Model.findOneAndUpdate([conditions], [update], [options], [callback]) findByIdAndUpdate 　　 fineByIdAndUpdate()方法的第四个参数回调函数的形式如下function(err,doc){} Model.findOneAndUpdate([conditions], [update], [options], [callback]) 文档删除 　　有三种方法用于文档删除 remove() findOneAndRemove() findByIdAndRemove() remove() 　　remove有两种形式，一种是文档的remove()方法，一种是Model的remove()方法 　　下面介绍Model的remove()方法，该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}　　 model.remove(conditions, [callback]) 　　删除数据库中名称包括'30'的数据 temp.remove({name:/30/},function(err){}) 　　[注意]remove()方法中的回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码 temp.remove({name:/30/}).exec() 　　下面介绍文档的remove()方法，该方法的参数回调函数的形式如下function(err,doc){} document.remove([callback]) 　　删除数据库中名称包含'huo'的数据 　　> [注意]文档的remove()方法的回调函数参数可以省略 temp.find({name:/huo/},function(err,doc){ doc.forEach(function(item,index,arr){ item.remove(function(err,doc){ //{ _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 30 } //{ _id: 5971f93be6f98ec60e3dc86e, name: 'huo', age: 60 } console.log(doc); }) }) }) findOneAndRemove() 　　model的remove()会删除符合条件的所有数据，如果只删除符合条件的第一条数据，则可以使用model的findOneAndRemove()方法 Model.findOneAndRemove(conditions, [options], [callback]) 　　集合temps现有数据如下 　　现在删除第一个年龄小于20的数据 temp.findOneAndRemove({age:{$lt:20}},function(err,doc){ //{ _id: 5972d3f3e6f98ec60e3dc873, name: 'wang', age: 18 } console.log(doc); }) 　　与model的remove()方法相同，回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码 temp.findOneAndRemove({age:{$lt:20}}).exec() findByIdAndRemove() Model.findByIdAndRemove(id, [options], [callback]) 　　删除第0个元素 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findByIdAndRemove(aIDArr[0],function(err,doc){ //{ _id: 5972d754e6f98ec60e3dc882, name: 'huochai', age: 27 } console.log(doc); }) }) 　　类似的，该方法也不能省略回调函数，否则数据不会被删除。当然，可以使用exec()方法来简写代码 var aIDArr = []; temp.find(function(err,docs){ docs.forEach(function(item,index,arr){ aIDArr.push(item._id); }) temp.findByIdAndRemove(aIDArr[0]).exec() }) 前后钩子 　　前后钩子即pre()和post()方法，又称为中间件，是在执行某些操作时可以执行的函数。中间件在schema上指定，类似于静态方法或实例方法等 　　可以在数据库执行下列操作时，设置前后钩子 init validate save remove count find findOne findOneAndRemove findOneAndUpdate insertMany update pre() 　　以find()方法为例，在执行find()方法之前，执行pre()方法 var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); schema.pre('find',function(next){ console.log('我是pre方法1'); next(); }); schema.pre('find',function(next){ console.log('我是pre方法2'); next(); }); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ console.log(docs[0]); }) /* 我是pre方法1 我是pre方法2 { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 } */ post() 　　post()方法并不是在执行某些操作后再去执行的方法，而在执行某些操作前最后执行的方法，post()方法里不可以使用next() var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); schema.post('find',function(docs){ console.log('我是post方法1'); }); schema.post('find',function(docs){ console.log('我是post方法2'); }); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ console.log(docs[0]); }) /* 我是post方法1 我是post方法2 { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 } */ 查询后处理 　　常用的查询后处理的方法如下所示 sort 排序 skip 跳过 limit 限制 select 显示字段 exect 执行 count 计数 distinct 去重 var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); temp.find(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }) sort() 　　按age从小到大排序 temp.find().sort(\"age\").exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 } ] console.log(docs); }); 　　按x从小到大，age从大到小排列 temp.find().sort(\"x -age\").exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }); skip() 　　跳过1个，显示其他 temp.find().skip(1).exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 }, //{ _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }); limit() 　　显示2个 temp.find().limit(2).exec(function(err,docs){ //[ { _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 }, //{ _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 } ] console.log(docs); }); select() 　　显示name、age字段，不显示_id字段 temp.find().select(\"name age -_id\").exec(function(err,docs){ //[ { name: 'huochai', age: 27 },{ name: 'wang', age: 18 },{ name: 'huo', age: 30 },{ name: 'li', age: 20 } ] console.log(docs); }); temp.find().select({name:1, age:1, _id:0}).exec(function(err,docs){ //[ { name: 'huochai', age: 27 },{ name: 'wang', age: 18 },{ name: 'huo', age: 30 },{ name: 'li', age: 20 } ] console.log(docs); }); 　　下面将以上方法结合起来使用，跳过第1个后，只显示2个数据，按照age由大到小排序，且不显示_id字段 temp.find().skip(1).limit(2).sort(\"-age\").select(\"-_id\").exec(function(err,docs){ //[ { name: 'huochai', age: 27, x: 1, y: 2 }, //{ name: 'li', age: 20, x: 2, y: 2 } ] console.log(docs); }); count() 　　显示集合temps中的文档数量 temp.find().count(function(err,count){ console.log(count);//4 }); distinct() 　　返回集合temps中的x的值 temp.find().distinct('x',function(err,distinct){ console.log(distinct);//[ 1, 2 ] }); 文档验证 　　为什么需要文档验证呢？以一个例子作为说明，schema进行如下定义 var schema = new mongoose.Schema({ age:Number, name: String,x:Number,y:Number}); 　　如果不进行文档验证，保存文档时，就可以不按照Schema设置的字段进行设置，分为以下几种情况 　　1、缺少字段的文档可以保存成功 var temp = mongoose.model('temp', schema); new temp({age:10}).save(function(err,doc){ //{ __v: 0, age: 10, _id: 597304442b70086a1ce3cf05 } console.log(doc); }); 　　2、包含未设置的字段的文档也可以保存成功，未设置的字段不被保存 new temp({age:100,abc:\"abc\"}).save(function(err,doc){ //{ __v: 0, age: 100, _id: 5973046a2bb57565b474f48b } console.log(doc); }); 　　3、包含字段类型与设置不同的字段的文档也可以保存成功，不同字段类型的字段被保存为设置的字段类型 new temp({age:true,name:10}).save(function(err,doc){ //{ __v: 0, age: 1, name: '10', _id: 597304f7a926033060255366 } console.log(doc); }); 　　而通过文档验证，就可以避免以下几种情况发生 　　文档验证在SchemaType中定义，格式如下 {name: {type:String, validator:value}} 　　常用验证包括以下几种 required: 数据必须填写 default: 默认值 validate: 自定义匹配 min: 最小值(只适用于数字) max: 最大值(只适用于数字) match: 正则匹配(只适用于字符串) enum: 枚举匹配(只适用于字符串) required 　　将age设置为必填字段，如果没有age字段，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:{type:Number,required:true}, name: String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:\"abc\"}).save(function(err,doc){ //Path `age` is required. console.log(err.errors['age'].message); }); default 　　设置age字段的默认值为18，如果不设置age字段，则会取默认值 var schema = new mongoose.Schema({ age:{type:Number,default:18}, name:String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'a'}).save(function(err,doc){ //{ __v: 0, name: 'a', _id: 59730d2e7a751d81582210c1, age: 18 } console.log(doc); }); min | max 　　将age的取值范围设置为[0,10]。如果age取值为20，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:{type:Number,min:0,max:10}, name: String,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({age:20}).save(function(err,doc){ //Path `age` (20) is more than maximum allowed value (10). console.log(err.errors['age'].message); }); match 　　将name的match设置为必须存在'a'字符。如果name不存在'a'，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:Number, name:{type:String,match:/a/},x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'bbb'}).save(function(err,doc){ //Path `name` is invalid (bbb). console.log(err.errors['name'].message); }); enum 　　将name的枚举取值设置为['a','b','c']，如果name不在枚举范围内取值，文档将不被保存，且出现错误提示 var schema = new mongoose.Schema({ age:Number, name:{type:String,enum:['a','b','c']},x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'bbb'}).save(function(err,doc){ //`bbb` is not a valid enum value for path `name`. console.log(err.errors['name'].message); }); validate 　　validate实际上是一个函数，函数的参数代表当前字段，返回true表示通过验证，返回false表示未通过验证。利用validate可以自定义任何条件。比如，定义名字name的长度必须在4个字符以上 var validateLength = function(arg){ if(arg.length > 4){ return true; } return false; }; var schema = new mongoose.Schema({ name:{type:String,validate:validateLength}, age:Number,x:Number,y:Number}); var temp = mongoose.model('temp', schema); new temp({name:'abc'}).save(function(err,doc){ //Validator failed for path `name` with value `abc` console.log(err.errors['name'].message); }); 联表操作 　　下面以一个实例的形式来介绍下mongoose中的联表操作population 　　以类别category和文章post之间的关联为例 　　其中，category的model如下所示 const mongoose = require('mongoose') const Schema = mongoose.Schema const CategorySchema = new Schema( { number: { type: Number, required: true, index: true, unique: true, min:[1000000000, '位数不足'], max: [9999999999, '位数过长'] }, name: { type: String, required: true, validate: { validator: (v) => v.trim().length, message: '名称不能为空'} }, description: { type: String }, posts: [{ type: Schema.Types.ObjectId, ref: 'Post' }], recommend: { type: Boolean }, index: { type: Number } }, { timestamps: true } ) module.exports = mongoose.model('Category', CategorySchema) 　　post的model如下所示 const mongoose = require('mongoose') const Schema = mongoose.Schema const PostSchema = new Schema( { title: { type: String, required: true, unique: true }, description: { type: String }, content: { type: String }, category: { type: Schema.Types.ObjectId, ref: 'Category', index: true }, comments: [{ type: Schema.Types.ObjectId, ref: 'Comment' }], likes: [{ type: Schema.Types.ObjectId, ref: 'Like' }], imgUrl: { type: String }, recommend: { type: Boolean }, index: { type: Number } }, { timestamps: true } ) module.exports = mongoose.model('Post', PostSchema) 　　在对类别的操作中， 都需要使用populate操作符显示出所包括的posts中的title /* 加载所有类别 */ app.get('/categories', (req, res) => { Category.find().populate('posts','title').select(\"number name description recommend index\").exec((err, docs) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) return res.status(200).json({code: 1, message: '获取类别成功', result: {docs}}) }) }) /* 新增一个类别 */ app.post('/categories', adminAuth, (req, res) => { new Category(req.body).save((err, doc) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) doc.populate({path:'posts',select:'title'}, (err, doc) => { if (err) return res.status(500).json({code:0, message: err.message, err}) return res.status(200).json({code: 1, message: '新增成功', result: {doc}}) }) }) }) ... 　　在对文章的操作中，则需要显示出类别category的number属性 /* 按照id加载一篇文章 */ app.get('/posts/:id', (req, res) => { Post.findById(req.params.id).populate('category','number').exec((err, doc) => { if (err) return res.status(500).json({code:0, message:err.message, err}) if (doc === null) return res.status(404).json({code:0, message:'文章不存在'}) return res.status(200).json({code:1, message:'获取文章成功', result:{doc}}) }) }) /* 加载所有文章 */ app.get('/posts', (req, res) => { Post.find().select(\"title likes comments recommend imgUrl index\").populate('category','number').sort(\"-createdAt\").exec((err, docs) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) return res.status(200).json({code: 1, message: '获取文章成功', result: {docs}}) }) 　　在新增、更新和删除文章的操作中，都需要重建与category的关联 // 关联category的posts数组 fnRelatedCategory = _id => { Category.findById(_id).exec((err, categoryDoc) => { if (err) return res.status(500).json({ code: 0, message: err.message, err }) if (categoryDoc === null) return res.status(404).json({code:0, message:'该类别不存在，请刷新后再试'}) Post.find({ category: _id }).exec((err, postsDocs) => { if (err) return res.status(500).json({ code: 0, message: err.message, err }) categoryDoc.posts = postsDocs.map(t => t._id) categoryDoc.save(err => { if (err) return res.status(500).json({ code: 0, message: err.message, err }) }) }) }) } /* 按照id更新一篇文章 */ app.put('/posts/:id', adminAuth, (req, res) => { Post.findById(req.params.id).exec((err, doc) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) if (doc === null) return res.status(404).json({code: 0, message: '文章不存在，请刷新后再试'}) for (prop in req.body) { doc[prop] = req.body[prop] } doc.save((err) => { if (err) return res.status(500).json({code: 0, message: err.message, err}) doc.populate({path:'category',select:'number'}, (err, doc) => { if (err) return res.status(500).json({code:0, message: err.message, err}) fnRelatedCategory(doc.category._id) return res.status(200).json({code: 1, message: '更新成功', result: {doc}}) }) }) }) }) ... "},"2.mongoose/2.5 DOC-Mongoose学习参考文档.html":{"url":"2.mongoose/2.5 DOC-Mongoose学习参考文档.html","title":"2.5 DOC-Mongoose学习参考文档","keywords":"","body":"Mongoose学习参考文档 前言：本学习参考文档仅供参考，如有问题，师请雅正 一、快速通道 1.1 名词解释 Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力 Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对 Entity ： 由Model创建的实体，他的操作也会影响数据库 注意： 1.本学习文档采用严格命名方式来区别不同对象，例如： var PersonSchema; //Person的文本属性 var PersonModel; //Person的数据库模型 var PersonEntity; //Person实体 2.Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。 1.2 准备工作 1.首先你必须安装MongoDB和NodeJS 2.在项目只能够创建一个数据库连接，如下: var mongoose = require('mongoose'); //引用mongoose模块 var db = mongoose.createConnection('localhost','test'); //创建一个数据库连接 3.打开本机localhost的test数据库时，我们可以监测是否有异常 db.on('error',console.error.bind(console,'连接错误:')); db.once('open',function(){ //一次打开记录 }); 注意： 成功开启数据库后，就可以执行数据库相应操作，假设以下代码都在回调中处理 4.定义一个Schema var PersonSchema = new mongoose.Schema({ name:String //定义一个属性name，类型为String }); 5.将该Schema发布为Model var PersonModel = db.model('Person',PersonSchema); //如果该Model已经发布，则可以直接通过名字索引到，如下： //var PersonModel = db.model('Person'); //如果没有发布，上一段代码将会异常 6.用Model创建Entity var personEntity = new PersonModel({name:'Krouky'}); //打印这个实体的名字看看 console.log(personEntity.name); //Krouky 7.我们甚至可以为此Schema创建方法 //为Schema模型追加speak方法 PersonSchema.methos.speak = function(){ console.log('我的名字叫'+this.name); } var PersonModel = db.model('Person',PersonSchema); var personEntity = new PersonModel({name:'Krouky'}); personEntity.speak();//我的名字叫Krouky 8.Entity是具有具体的数据库操作CRUD的 personEntity.save(); //执行完成后，数据库就有该数据了 9.如果要执行查询，需要依赖Model，当然Entity也是可以做到的 PersonModel.find(function(err,persons){ //查询到的所有person }); 注意： 具体的如何配置Schema、Model以及Model和Entity的相关操作，我们会在后面进行 Model和Entity都有能影响数据库的操作，但仍有区别，后面我们也会做解释 二、新手指引 如果您还不清楚Mongoose是如何工作的，请参看第一章快速通道快速浏览他的用法吧 1.Schema——纯洁的数据库原型 1.1 什么是Schema 我理解Schema仅仅只是一断代码，他书写完成后程序依然无法使用，更无法通往数据库端 他仅仅只是数据库模型在程序片段中的一种表现，或者是数据属性模型 1.2 如何定义Schema var BlogSchema = new Schema({ title:String, author:String //new Schema()中传入一个JSON对象，该对象形如 xxx:yyyy , /xxx是一个字符串，定义了属性，yyy是一个Schema.Type，定义了属性类型 }); 1.3 什么是Schema.Type Schema.Type是由Mongoose内定的一些数据类型，基本数据类型都在其中，他也内置了一些Mongoose特有的Schema.Type。当然，你也可以自定义Schema.Type，只有满足Schema.Type的类型才能定义在Schema内。 1.4 Schema.Types NodeJS中的基本数据类型都属于Schema.Type，另外Mongoose还定义了自己的类型 //举例： var ExampleSchema = new Schema({ name:String, binary:Buffer, living:Boolean, updated:Date, age:Number, mixed:Schema.Types.Mixed, //该混合类型等同于nested _id:Schema.Types.ObjectId, //主键 _fk:Schema.Types.ObjectId, //外键 array:[], arrOfString:[String], arrOfNumber:[Number], arrOfDate:[Date], arrOfBuffer:[Buffer], arrOfBoolean:[Boolean], arrOfMixed:[Schema.Types.Mixed], arrOfObjectId:[Schema.Types.ObjectId] nested:{ stuff:String, } }); 1.5 关于Buffer Buffer`和`ArrayBuffer`是`Nodejs`两种隐藏的对象，相关内容请查看`NodeJS-API 1.6 关于Mixed Schema.Types.Mixed是Mongoose定义个混合类型，该混合类型如果未定义具体形式。因此,如果定义具体内容，就直接使用{}来定义，以下两句等价 var AnySchema = new Schema({any:{}}); var AnySchema = new Schema({any:Schema.Types.Mixed}); 混合类型因为没有特定约束，因此可以任意修改，一旦修改了原型，则必须调用markModified() person.anything = {x:[3,4,{y:'change'}]} person.markModified('anything');//传入anything，表示该属性类型发生变化 person.save(); 1.7 关于ObjectId 主键，一种特殊而且非常重要的类型，每个Schema都会默认配置这个属性，属性名为_id，除非自己定义，方可覆盖 var mongoose = require('mongoose'); var ObjectId = mongoose.Schema.Types.ObjectId; var StudentSchema = new Schema({}); //默认会有_id:ObjectId var TeacherSchema = new Schema({id:ObjectId});//只有id:ObjectId 该类型的值由系统自己生成，从某种意义上几乎不会重复，生成过程比较复杂，有兴趣的朋友可以查看源码。 1.8 关于Array Array在JavaScript编程语言中并不是数组，而是集合，因此里面可以存入不同的值，以下代码等价： var ExampleSchema1 = new Schema({array:[]}); var ExampleSchema2 = new Schema({array:Array}); var ExampleSchema3 = new Schema({array:[Schema.Types.Mixed]}); var ExampleSchema4 = new Schema({array:[{}]}); 1.9 附言 Schema`不仅定义了`文档结构`和`使用性能`，还可以有`扩展插件`、`实例方法`、`静态方法`、`复合索引`、`文档生命周期钩子 Schema可以定义插件，并且插件具有良好的可拔插性，请有兴趣的读者继续往后阅读或者查阅官方资料。 2. Schema的扩展 2.1 实例方法 有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法。 下面例子比快速通道的例子更加高级，可以进行高级扩展： var PersonSchema = new Schema({name:String,type:String}); //查询类似数据 PersonSchema.methods.findSimilarTypes = function(cb){ return this.model('Person').find({type:this.type},cb); } 使用如下： var PersonModel = mongoose.model('Person',PersonSchema); var krouky = new PersonSchema({name:'krouky',type:'前端工程师'}); krouky.findSimilarTypes(function(err,persons){ //persons中就能查询到其他前端工程师 }); 2.2 静态方法 静态方法在Model层就能使用，如下： PersonSchema.statics.findByName = function(name,cb){ this.find({name:new RegExp(name,'i'),cb}); } var PersonModel = mongoose.model('Person',PersonSchema); PersonModel.findByName('krouky',function(err,persons){ //找到所有名字叫krouky的人 }); 2.3 索引 索引或者复合索引能让搜索更加高效，默认索引就是主键索引ObjectId，属性名为_id， 索引会作为一个专题来讲解 2.4 虚拟属性 Schema中如果定义了虚拟属性，那么该属性将不写入数据库，例如： var PersonSchema = new Schema({ name:{ first:String, last:String } }); var PersonModel = mongoose.model('Person',PersonSchema); var krouky = new PersonModel({ name:{first:'krouky',last:'han'} }); 如果每次想使用全名就得这样 console.log(krouky.name.first + ' ' + krouky.name.last); 显然这是很麻烦的，我们可以定义虚拟属性： PersonSchema.virtual('name.full').get(function(){ return this.name.first + ' ' + this.name.last; }); 那么就能用krouky.name.full来调用全名了，反之如果知道full，也可以反解first和last属性 PersonSchema.virtual('name.full').set(function(name){ var split = name.split(' '); this.name.first = split[0]; this.name.last = split[1]; }); var PersonModel = mongoose.model('Person',PersonSchema); var krouky = new PersonModel({}); krouky.name.full = 'krouky han';//会被自动分解 console.log(krouky.name.first);//krouky 2.5 配置项 在使用new Schema(config)时，我们可以追加一个参数options来配置Schema的配置，形如： var ExampleSchema = new Schema(config,options); 或者使用 var ExampleSchema = new Schema(config); ExampleSchema.set(option,value); 可供配置项有：safe、strict、capped、versionKey、autoIndex 2.5.1 safe——安全属性（默认安全） 一般可做如下配置： new Schema({...},{safe:true}); 当然我们也可以这样 new Schema({...},{safe:{j:1,w:2,wtimeout:10000}}); j表示做1份日志，w表示做2个副本（尚不明确），超时时间10秒 2.5.2 strict——严格配置（默认启用） 确保Entity的值存入数据库前会被自动验证，如果你没有充足的理由，请不要停用，例子： var ThingSchema = new Schema({a:String}); var ThingModel = db.model('Thing',SchemaSchema); var thing = new Thing({iAmNotInTheThingSchema:true}); thing.save();//iAmNotInTheThingSchema这个属性将无法被存储 如果取消严格选项，iAmNotInTheThingSchema将会被存入数据库 该选项也可以在构造实例时使用，例如： var ThingModel = db.model('Thing'); var thing1 = new ThingModel(doc,true); //启用严格 var thing2 = new ThingModel(doc,false); //禁用严格 注意： strict也可以设置为throw，表示出现问题将会抛出错误 2.5.3 shardKey 需要mongodb做分布式，才会使用该属性 2.5.4 capped——上限设置 如果有数据库的批量操作，该属性能限制一次操作的量，例如： new Schema({...},{capped:1024}); //一次操作上线1024条数据 当然该参数也可是JSON对象，包含size、max、autiIndexId属性 new Schema({...},{capped:{size:1024,max:100,autoIndexId:true}}); 2.5.5 versionKey——版本锁 版本锁是Mongoose默认配置（__v属性）的，如果你想自己定制，如下： new Schema({...},{versionKey:'__someElse'}); 此时存入数据库的版本锁就不是__v属性，而是__someElse，相当于是给版本锁取名字。 具体怎么存入都是由Mongoose和MongoDB自己决定，当然，这个属性你也可以去除 new Schema({...},{versionKey:false}); 除非你知道你在做什么，并且你知道这样做的后果 2.5.6 autoIndex——自动索引 该内容将在索引章节单独讲解 3. Documents Document是与MongoDB文档一一对应的模型，Document可等同于Entity，具有属性和操作性 注意： Document的`CRUD都必须经过严格验证的，参看2.5.2 Schema的strict严格配置 3.1 查询 查询内容过多，专题讲解 3.2 更新 有许多方式来更新文件，以下是常用的传统方式： PersonModel.findById(id,function(err,person){ person.name = 'MDragon'; person.save(function(err){}); }); 这里，利用Model模型查询到了person对象，该对象属于Entity，可以有save操作，如果使用Model`操作，需注意： PersonModel.findById(id,function(err,person){ person.name = 'MDragon'; var _id = person._id; //需要取出主键_id delete person._id; //再将其删除 PersonModel.update({_id:_id},person,function(err){}); //此时才能用Model操作，否则报错 }); update第一个参数是查询条件，第二个参数是更新的对象，但不能更新主键，这就是为什么要删除主键的原因。 当然这样的更新很麻烦，可以使用$set属性来配置，这样也不用先查询，如果更新的数据比较少，可用性还是很好的： PersonModel.update({_id:_id},{$set:{name:'MDragon'}},function(err){}); 需要注意，Document的CRUD操作都是异步执行，callback第一个参数必须是err，而第二个参数各个方法不一样，update的callback第二个参数是更新的数量，如果要返回更新后的对象，则要使用如下方法 Person.findByIdAndUpdate(_id,{$set:{name:'MDragon'}},function(err,person){ console.log(person.name); //MDragon }); 类似的方法还有findByIdAndRemove，如同名字，只能根据id查询并作update/remove操作，操作的数据仅一条 3.3 新增 如果是Entity，使用save方法，如果是Model，使用create方法 //使用Entity来增加一条数据 var krouky = new PersonModel({name:'krouky'}); krouky.save(callback); //使用Model来增加一条数据 var MDragon = {name:'MDragon'}; PersonModel.create(MDragon,callback); 两种新增方法区别在于，如果使用Model新增时，传入的对象只能是纯净的JSON对象，不能是由Model创建的实体，原因是：由Model创建的实体krouky虽然打印是只有{name:'krouky'}，但是krouky属于Entity，包含有Schema属性和Model数据库行为模型。如果是使用Model创建的对象，传入时一定会将隐藏属性也存入数据库，虽然3.x追加了默认严格属性，但也不必要增加操作的报错 3.4 删除 和新增一样，删除也有2种方式，但Entity和Model都使用remove方法 4.Sub Docs 如同SQL数据库中2张表有主外关系，Mongoose将2个Document的嵌套叫做Sub-Docs（子文档） 简单的说就是一个Document嵌套另外一个Document或者Documents: var ChildSchema1 = new Schema({name:String}); var ChildSchema2 = new Schema({name:String}); var ParentSchema = new Schema({ children1:ChildSchema1, //嵌套Document children2:[ChildSchema2] //嵌套Documents }); Sub-Docs享受和Documents一样的操作，但是Sub-Docs的操作都由父类去执行 var ParentModel = db.model('Parent',parentSchema); var parent = new ParentModel({ children2:[{name:'c1'},{name:'c2'}] }); parent.children2[0].name = 'd'; parent.save(callback); parent在执行保存时，由于包含children2，他是一个数据库模型对象，因此会先保存chilren2[0]和chilren2[1]。 如果子文档在更新时出现错误，将直接报在父类文档中，可以这样处理： ChildrenSchema.pre('save',function(next){ if('x' === this.name) return next(new Error('#err:not-x')); next(); }); var parent = new ParentModel({children1:{name:'not-x'}}); parent.save(function(err){ console.log(err.message); //#err:not-x }); 4.1 查询子文档 如果children是parent的子文档，可以通过如下方法查询到children var child = parent.children.id(id); 4.2 新增、删除、更新 子文档是父文档的一个属性，因此按照属性的操作即可，不同的是在新增父类的时候，子文档是会被先加入进去的。 如果ChildrenSchema是临时的一个子文档，不作为数据库映射集合，可以这样： var ParentSchema = new Schema({ children:{ name:String } }); //其实就是匿名混合模式 5.Model 5.1 什么是Model Model模型，是经过Schema构造来的，除了Schema定义的数据库骨架以外，还具有数据库行为模型，他相当于管理数据库属性、行为的类 5.2 如何创建Model 你必须通过Schema来创建，如下： //先创建Schema var TankSchema = new Schema({ name:'String', size:'String' }); //通过Schema创建Model var TankModel = mongoose.model('Tank',TankSchema); 5.2 操作Model 该模型就能直接拿来操作，具体查看API，例如： var tank = {'something',size:'small'}; TankModel.create(tank); 注意： 你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。 //通过Model创建Entity var tankEntity = new TankModel('someother','size:big'); tankEntity.save(); 6.Query 查询是数据库中运用最多也是最麻烦的地方，这里对Query解读的并不完善，仅仅是自己的一点领悟而已。 6.1 查询的方式 通常有2种查询方式，一种是直接查询，一种是链式查询（2种查询都是自己命名的） 6.1.1 直接查询 在查询时带有回调函数的，称之为直接查询，查询的条件往往通过API来设定，例如： PersonModel.findOne({'name.last':'dragon'},'some select',function(err,person){ //如果err==null，则person就能取到数据 }); 具体的查询参数，请查询API 6.1.2 链式查询 在查询时候，不带回调，而查询条件通过API函数来制定，例如： var query = PersonModel.findOne({'name.last':'dragon'}); query.select('some select'); query.exec(function(err,pserson){ //如果err==null，则person就能取到数据 }); 这种方式相对直接查询，分的比较明细，如果不带callback，则返回query，query没有执行的预编译查询语句，该query对象执行的方法都将返回自己，只有在执行exec方法时才执行查询，而且必须有回调。 因为query的操作始终返回自身，我们可以采用更形象的链式写法 Person .find({ occupation: /host/ }) .where('name.last').equals('Ghost') .where('age').gt(17).lt(66) .where('likes').in(['vaporizing', 'talking']) .limit(10) .sort('-occupation') .select('name occupation') .hint({age:1,name:1,like:-1}) //是否启用稀疏索引 也就是如果这内部的没有值则跳过该值 1 标识需要 2标识不需要 .exec(callback); 7.Validation 数据的存储是需要验证的，不是什么数据都能往数据库里丢或者显示到客户端的，数据的验证需要记住以下规则： 验证始终定义在SchemaType中 验证是一个内部中间件 验证是在一个Document被保存时默认启用的，除非你关闭验证 验证是异步递归的，如果你的SubDoc验证失败，Document也将无法保存 验证并不关心错误类型，而通过ValidationError这个对象可以访问 7.1 验证器 required 非空验证 min/max 范围验证（边值验证） enum/match 枚举验证/匹配验证 validate 自定义验证规则 以下是综合案例： var PersonSchema = new Schema({ name:{ type:'String', required:true //姓名非空 }, age:{ type:'Nunmer', min:18, //年龄最小18 max:120 //年龄最大120 }, city:{ type:'String', enum:['北京','上海'] //只能是北京、上海人 }, other:{ type:'String', validate:[validator,err] //validator是一个验证函数，err是验证失败的错误信息 } }); 7.2 验证失败 如果验证失败，则会返回err信息，err是一个对象该对象属性如下 err.errors //错误集合（对象） err.errors.color //错误属性(Schema的color属性) err.errors.color.message //错误属性信息 err.errors.path //错误属性路径 err.errors.type //错误类型 err.name //错误名称 err.message //错误消息 一旦验证失败，Model和Entity都将具有和err一样的errors属性 8.Middleware中间件 8.1 什么是中间件 中间件是一种控制函数，类似插件，能控制流程中的init、validate、save、remove`方法 8.2 中间件的分类 中间件分为两类 8.2.1 Serial串行 串行使用pre方法，执行下一个方法使用next调用 var schema = new Schema(...); schema.pre('save',function(next){ //做点什么 next(); }); 8.2.2 Parallel并行 并行提供更细粒度的操作 var schema = new Schema(...); schema.pre('save',function(next,done){ //下一个要执行的中间件并行执行 next(); doAsync(done); }); 8.3 中间件特点 一旦定义了中间件，就会在全部中间件执行完后执行其他操作，使用中间件可以雾化模型，避免异步操作的层层迭代嵌套 8.4 使用范畴 复杂的验证 删除有主外关联的doc 异步默认 某个特定动作触发异步任务，例如触发自定义事件和通知 例如，可以用来做自定义错误处理 schema.pre('save',function(next){ var err = new Eerror('some err'); next(err); }); entity.save(function(err){ console.log(err.message); //some err }); "}}